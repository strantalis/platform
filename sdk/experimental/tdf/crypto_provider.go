// Experimental: This package is EXPERIMENTAL and may change or be removed at any time

package tdf

// CryptoProvider supplies all cryptographic primitives that the experimental
// TDF writer depends on. Implementations may execute operations locally, proxy
// them to a host environment (for example via WASM imports), or enforce
// additional policy constraints. Callers must treat the provider as the single
// source of cryptographic truth and avoid mixing it with ad-hoc helpers.
//
// The interface composes narrower capability interfaces so implementations can
// express partial functionality while still satisfying the top-level contract.
type CryptoProvider interface {
	EntropySource
	AEADCipherFactory
	EncodingProvider
	IntegrityProvider
	KeyWrapProvider
}

// EntropySource exposes secure randomness. Returned buffers must be freshly
// allocated and the provider must not retain references after the call.
type EntropySource interface {
	// RandomBytes returns cryptographically secure random bytes of the
	// requested length. Implementations should return an error if sufficient
	// entropy is unavailable.
	RandomBytes(length int) ([]byte, error)
}

// AEADCipherFactory creates AES-GCM ciphers backed by the provider. Callers
// treat the returned AEAD as stateful but safe for single goroutine use unless
// documented otherwise by the implementation.
type AEADCipherFactory interface {
	// NewAESGCM constructs an AES-GCM cipher using the supplied key. The key is
	// owned by the caller; providers must not mutate it and should return an
	// error when the key size is unsupported.
	NewAESGCM(key []byte) (AESGCM, error)
}

// AESGCM defines the AES-GCM operations required by the TDF writer. Unless
// noted the methods allocate fresh output buffers that the caller owns.
type AESGCM interface {
	// Encrypt returns nonce||ciphertext for the supplied plaintext using a
	// nonce generated by the implementation.
	Encrypt(plaintext []byte) ([]byte, error)

	// EncryptWithIV encrypts the plaintext using the provided IV. The IV is not
	// copied; callers must not modify it after the call. Implementations may
	// return an error if the IV length is invalid.
	EncryptWithIV(iv, plaintext []byte) ([]byte, error)

	// EncryptWithIVAndTagSize behaves like EncryptWithIV but allows specifying a
	// custom authentication tag size. Implementations must return an error when
	// either the IV or tag size is unsupported.
	EncryptWithIVAndTagSize(iv, plaintext []byte, tagSize int) ([]byte, error)

	// Decrypt decrypts nonce||ciphertext produced by Encrypt. The returned
	// buffer is freshly allocated.
	Decrypt(ciphertext []byte) ([]byte, error)

	// DecryptWithTagSize decrypts data produced by EncryptWithIVAndTagSize using
	// the provided tag size. The nonce is expected to be prepended to ciphertext
	// as in Encrypt.
	DecryptWithTagSize(ciphertext []byte, tagSize int) ([]byte, error)

	// DecryptWithIVAndTagSize decrypts ciphertext using the supplied IV and tag
	// size. Implementations may reject mismatched lengths.
	DecryptWithIVAndTagSize(iv, ciphertext []byte, tagSize int) ([]byte, error)
}

// EncodingProvider exposes reversible encodings that the writer requires for
// manifest serialization. Implementations must treat inputs as immutable and
// return newly allocated slices.
type EncodingProvider interface {
	// Base64Encode encodes data using standard base64 without padding changes.
	Base64Encode(data []byte) []byte

	// Base64Decode decodes base64-encoded data. Providers must either return
	// a freshly allocated buffer or an error when the input is malformed.
	Base64Decode(data []byte) ([]byte, error)
}

// IntegrityProvider calculates integrity digests used across the writer.
// Outputs must be deterministic for a given input and the provider must not
// reuse internal buffers when returning results.
type IntegrityProvider interface {
	// HMACSHA256 computes an HMAC using SHA-256. Implementations may return an
	// error if the operation fails.
	HMACSHA256(key, data []byte) ([]byte, error)
}

// KeyWrapProvider wraps symmetric keys for distribution to a KAS. The
// high-level operation allows the provider to choose how much work is handled
// natively versus delegated to a host environment.
type KeyWrapProvider interface {
	// WrapKey encrypts or otherwise protects the plaintext key material for the
	// specified public key. The Algorithm field follows the strings produced by
	// policy metadata (for example "rsa:2048" or "ec:secp256r1"). Salt conveys
	// the TDF salt to use for HKDF-based schemes; providers can ignore it when
	// not applicable. Implementations must not retain references to any input
	// buffers.
	WrapKey(req KeyWrapRequest) (KeyWrapResult, error)
}

// KeyWrapRequest describes the parameters for wrapping a symmetric key.
type KeyWrapRequest struct {
	// Algorithm identifies the KAS public key type (e.g., "rsa:2048").
	Algorithm string

	// PublicKeyPEM contains the PEM-encoded public key material supplied by the
	// policy. The provider must treat it as read-only.
	PublicKeyPEM string

	// PlaintextKey is the symmetric key bytes that need to be wrapped. The
	// caller owns the buffer and may reuse it after the call returns.
	PlaintextKey []byte

	// Salt provides an optional salt for HKDF-style schemes. It may be nil when
	// not required by the algorithm.
	Salt []byte
}

// KeyWrapResult captures the output of a key wrapping operation.
type KeyWrapResult struct {
	// WrappedKey contains the protected key bytes. Callers are responsible for
	// applying any additional encoding (for example base64) prior to manifest
	// serialization.
	WrappedKey []byte

	// Scheme identifies the wrapping scheme so call sites can populate the TDF
	// manifest. It typically maps to values such as "wrapped" (RSA-OAEP) or
	// "eccWrapped" (ECIES/HKDF).
	Scheme KeyWrapScheme

	// EphemeralPublicKey holds an optional PEM-encoded ephemeral public key that
	// KAS clients require for EC-based schemes. It should be empty for RSA.
	EphemeralPublicKey string
}

// KeyWrapScheme enumerates supported key wrapping scheme identifiers.
type KeyWrapScheme string

const (
	// KeyWrapSchemeRSA indicates RSA-OAEP wrapping (aka "wrapped").
	KeyWrapSchemeRSA KeyWrapScheme = "wrapped"

	// KeyWrapSchemeEC indicates EC-based wrapping with an ephemeral key (aka
	// "eccWrapped").
	KeyWrapSchemeEC KeyWrapScheme = "eccWrapped"
)
