// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: resource_mapping.sql

package dbsqlite

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createResourceMapping = `-- name: CreateResourceMapping :one
INSERT INTO resource_mappings (id, attribute_value_id, terms, metadata, group_id, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, $3, $4, STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'), STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'))
RETURNING id
`

type CreateResourceMappingParams struct {
	AttributeValueID sql.NullString `json:"attribute_value_id"`
	Terms            sql.NullString `json:"terms"`
	Metadata         sql.NullString `json:"metadata"`
	GroupID          sql.NullString `json:"group_id"`
}

// CreateResourceMapping
//
//	INSERT INTO resource_mappings (id, attribute_value_id, terms, metadata, group_id, created_at, updated_at)
//	VALUES (gen_random_uuid(), $1, $2, $3, $4, STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'), STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'))
//	RETURNING id
func (q *Queries) CreateResourceMapping(ctx context.Context, arg CreateResourceMappingParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createResourceMapping,
		arg.AttributeValueID,
		arg.Terms,
		arg.Metadata,
		arg.GroupID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createResourceMappingGroup = `-- name: CreateResourceMappingGroup :one
INSERT INTO resource_mapping_groups (id, namespace_id, name, metadata, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, $3, STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'), STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'))
RETURNING id
`

type CreateResourceMappingGroupParams struct {
	NamespaceID sql.NullString `json:"namespace_id"`
	Name        sql.NullString `json:"name"`
	Metadata    sql.NullString `json:"metadata"`
}

// CreateResourceMappingGroup
//
//	INSERT INTO resource_mapping_groups (id, namespace_id, name, metadata, created_at, updated_at)
//	VALUES (gen_random_uuid(), $1, $2, $3, STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'), STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'))
//	RETURNING id
func (q *Queries) CreateResourceMappingGroup(ctx context.Context, arg CreateResourceMappingGroupParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createResourceMappingGroup, arg.NamespaceID, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteResourceMapping = `-- name: DeleteResourceMapping :execrows
DELETE FROM resource_mappings WHERE id = $1
`

// DeleteResourceMapping
//
//	DELETE FROM resource_mappings WHERE id = $1
func (q *Queries) DeleteResourceMapping(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteResourceMapping, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteResourceMappingGroup = `-- name: DeleteResourceMappingGroup :execrows
DELETE FROM resource_mapping_groups WHERE id = $1
`

// DeleteResourceMappingGroup
//
//	DELETE FROM resource_mapping_groups WHERE id = $1
func (q *Queries) DeleteResourceMappingGroup(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteResourceMappingGroup, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getResourceMapping = `-- name: GetResourceMapping :one
SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(m.metadata, '$.labels'), 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    COALESCE(m.group_id, '') as group_id
FROM resource_mappings m 
LEFT JOIN attribute_values av on m.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
WHERE m.id = $1
GROUP BY av.id, m.id, fqns.fqn
`

type GetResourceMappingRow struct {
	ID             string          `json:"id"`
	AttributeValue json.RawMessage `json:"attribute_value"`
	Terms          sql.NullString  `json:"terms"`
	Metadata       json.RawMessage `json:"metadata"`
	GroupID        string          `json:"group_id"`
}

// GetResourceMapping
//
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(m.metadata, '$.labels'), 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    COALESCE(m.group_id, '') as group_id
//	FROM resource_mappings m
//	LEFT JOIN attribute_values av on m.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	WHERE m.id = $1
//	GROUP BY av.id, m.id, fqns.fqn
func (q *Queries) GetResourceMapping(ctx context.Context, id string) (GetResourceMappingRow, error) {
	row := q.db.QueryRowContext(ctx, getResourceMapping, id)
	var i GetResourceMappingRow
	err := row.Scan(
		&i.ID,
		&i.AttributeValue,
		&i.Terms,
		&i.Metadata,
		&i.GroupID,
	)
	return i, err
}

const getResourceMappingGroup = `-- name: GetResourceMappingGroup :one
SELECT id, namespace_id, name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(metadata, '$.labels'), 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM resource_mapping_groups
WHERE id = $1
`

type GetResourceMappingGroupRow struct {
	ID          string          `json:"id"`
	NamespaceID sql.NullString  `json:"namespace_id"`
	Name        sql.NullString  `json:"name"`
	Metadata    json.RawMessage `json:"metadata"`
}

// GetResourceMappingGroup
//
//	SELECT id, namespace_id, name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(metadata, '$.labels'), 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM resource_mapping_groups
//	WHERE id = $1
func (q *Queries) GetResourceMappingGroup(ctx context.Context, id string) (GetResourceMappingGroupRow, error) {
	row := q.db.QueryRowContext(ctx, getResourceMappingGroup, id)
	var i GetResourceMappingGroupRow
	err := row.Scan(
		&i.ID,
		&i.NamespaceID,
		&i.Name,
		&i.Metadata,
	)
	return i, err
}

const listResourceMappingGroups = `-- name: ListResourceMappingGroups :many

SELECT rmg.id,
    rmg.namespace_id,
    rmg.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(rmg.metadata, '$.labels'), 'created_at', rmg.created_at, 'updated_at', rmg.updated_at)) as metadata,
    COUNT(*) OVER() AS total
FROM resource_mapping_groups rmg
WHERE ($1 IS NULL OR rmg.namespace_id = $1) 
ORDER BY rmg.created_at DESC
LIMIT $3 
OFFSET $2
`

type ListResourceMappingGroupsParams struct {
	NamespaceID interface{} `json:"namespace_id"`
	Offset      int32       `json:"offset_"`
	Limit       int32       `json:"limit_"`
}

type ListResourceMappingGroupsRow struct {
	ID          string          `json:"id"`
	NamespaceID sql.NullString  `json:"namespace_id"`
	Name        sql.NullString  `json:"name"`
	Metadata    json.RawMessage `json:"metadata"`
	Total       int64           `json:"total"`
}

// --------------------------------------------------------------
// RESOURCE MAPPING GROUPS
// --------------------------------------------------------------
//
//	SELECT rmg.id,
//	    rmg.namespace_id,
//	    rmg.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(rmg.metadata, '$.labels'), 'created_at', rmg.created_at, 'updated_at', rmg.updated_at)) as metadata,
//	    COUNT(*) OVER() AS total
//	FROM resource_mapping_groups rmg
//	WHERE ($1 IS NULL OR rmg.namespace_id = $1)
//	ORDER BY rmg.created_at DESC
//	LIMIT $3
//	OFFSET $2
func (q *Queries) ListResourceMappingGroups(ctx context.Context, arg ListResourceMappingGroupsParams) ([]ListResourceMappingGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listResourceMappingGroups, arg.NamespaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceMappingGroupsRow
	for rows.Next() {
		var i ListResourceMappingGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.NamespaceID,
			&i.Name,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappings = `-- name: ListResourceMappings :many

SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(m.metadata, '$.labels'), 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    JSON_STRIP_NULLS(
        JSON_BUILD_OBJECT(
            'id', rmg.id,
            'name', rmg.name,
            'namespace_id', rmg.namespace_id
        )
    ) AS "group",
    COUNT(*) OVER() AS total
FROM resource_mappings m
LEFT JOIN attribute_values av on m.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
LEFT JOIN resource_mapping_groups rmg ON m.group_id = rmg.id
WHERE ($1 IS NULL OR m.group_id = $1)
GROUP BY av.id, m.id, fqns.fqn, rmg.id, rmg.name, rmg.namespace_id
ORDER BY m.created_at DESC
LIMIT $3 
OFFSET $2
`

type ListResourceMappingsParams struct {
	GroupID interface{} `json:"group_id"`
	Offset  int32       `json:"offset_"`
	Limit   int32       `json:"limit_"`
}

type ListResourceMappingsRow struct {
	ID             string          `json:"id"`
	AttributeValue json.RawMessage `json:"attribute_value"`
	Terms          sql.NullString  `json:"terms"`
	Metadata       json.RawMessage `json:"metadata"`
	Group          json.RawMessage `json:"group"`
	Total          int64           `json:"total"`
}

// --------------------------------------------------------------
// RESOURCE MAPPING
// --------------------------------------------------------------
//
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(m.metadata, '$.labels'), 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    JSON_STRIP_NULLS(
//	        JSON_BUILD_OBJECT(
//	            'id', rmg.id,
//	            'name', rmg.name,
//	            'namespace_id', rmg.namespace_id
//	        )
//	    ) AS "group",
//	    COUNT(*) OVER() AS total
//	FROM resource_mappings m
//	LEFT JOIN attribute_values av on m.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	LEFT JOIN resource_mapping_groups rmg ON m.group_id = rmg.id
//	WHERE ($1 IS NULL OR m.group_id = $1)
//	GROUP BY av.id, m.id, fqns.fqn, rmg.id, rmg.name, rmg.namespace_id
//	ORDER BY m.created_at DESC
//	LIMIT $3
//	OFFSET $2
func (q *Queries) ListResourceMappings(ctx context.Context, arg ListResourceMappingsParams) ([]ListResourceMappingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listResourceMappings, arg.GroupID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceMappingsRow
	for rows.Next() {
		var i ListResourceMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeValue,
			&i.Terms,
			&i.Metadata,
			&i.Group,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappingsByFullyQualifiedGroup = `-- name: ListResourceMappingsByFullyQualifiedGroup :many
WITH groups_cte AS (
    SELECT
        g.id,
        JSON_BUILD_OBJECT(
            'id', g.id,
            'namespace_id', g.namespace_id,
            'name', g.name,
            'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                'labels', json_extract(g.metadata, '$.labels'),
                'created_at', g.created_at,
                'updated_at', g.updated_at
            ))
        ) as "group"
    FROM resource_mapping_groups g
    JOIN attribute_namespaces ns on g.namespace_id = ns.id
    WHERE ns.name = $1 AND g.name = $2 
)
SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(m.metadata, '$.labels'), 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    g."group"
FROM resource_mappings m
JOIN groups_cte g ON m.group_id = g.id
JOIN attribute_values av on m.attribute_value_id = av.id
JOIN attribute_fqns fqns on av.id = fqns.value_id
ORDER BY m.created_at DESC
`

type ListResourceMappingsByFullyQualifiedGroupParams struct {
	NamespaceName string         `json:"namespace_name"`
	GroupName     sql.NullString `json:"group_name"`
}

type ListResourceMappingsByFullyQualifiedGroupRow struct {
	ID             string          `json:"id"`
	AttributeValue json.RawMessage `json:"attribute_value"`
	Terms          sql.NullString  `json:"terms"`
	Metadata       json.RawMessage `json:"metadata"`
	Group          json.RawMessage `json:"group"`
}

// CTE to cache the group JSON build since it will be the same for all mappings of the group
//
//	WITH groups_cte AS (
//	    SELECT
//	        g.id,
//	        JSON_BUILD_OBJECT(
//	            'id', g.id,
//	            'namespace_id', g.namespace_id,
//	            'name', g.name,
//	            'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                'labels', json_extract(g.metadata, '$.labels'),
//	                'created_at', g.created_at,
//	                'updated_at', g.updated_at
//	            ))
//	        ) as "group"
//	    FROM resource_mapping_groups g
//	    JOIN attribute_namespaces ns on g.namespace_id = ns.id
//	    WHERE ns.name = $1 AND g.name = $2
//	)
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(m.metadata, '$.labels'), 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    g."group"
//	FROM resource_mappings m
//	JOIN groups_cte g ON m.group_id = g.id
//	JOIN attribute_values av on m.attribute_value_id = av.id
//	JOIN attribute_fqns fqns on av.id = fqns.value_id
//	ORDER BY m.created_at DESC
func (q *Queries) ListResourceMappingsByFullyQualifiedGroup(ctx context.Context, arg ListResourceMappingsByFullyQualifiedGroupParams) ([]ListResourceMappingsByFullyQualifiedGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, listResourceMappingsByFullyQualifiedGroup, arg.NamespaceName, arg.GroupName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceMappingsByFullyQualifiedGroupRow
	for rows.Next() {
		var i ListResourceMappingsByFullyQualifiedGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeValue,
			&i.Terms,
			&i.Metadata,
			&i.Group,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResourceMapping = `-- name: UpdateResourceMapping :execrows
UPDATE resource_mappings
SET
    attribute_value_id = COALESCE($2, attribute_value_id),
    terms = COALESCE($3, terms),
    metadata = COALESCE($4, metadata),
    group_id = COALESCE($5, group_id),
    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = $1
`

type UpdateResourceMappingParams struct {
	ID               string         `json:"id"`
	AttributeValueID sql.NullString `json:"attribute_value_id"`
	Terms            sql.NullString `json:"terms"`
	Metadata         sql.NullString `json:"metadata"`
	GroupID          sql.NullString `json:"group_id"`
}

// UpdateResourceMapping
//
//	UPDATE resource_mappings
//	SET
//	    attribute_value_id = COALESCE($2, attribute_value_id),
//	    terms = COALESCE($3, terms),
//	    metadata = COALESCE($4, metadata),
//	    group_id = COALESCE($5, group_id),
//	    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
//	WHERE id = $1
func (q *Queries) UpdateResourceMapping(ctx context.Context, arg UpdateResourceMappingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateResourceMapping,
		arg.ID,
		arg.AttributeValueID,
		arg.Terms,
		arg.Metadata,
		arg.GroupID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateResourceMappingGroup = `-- name: UpdateResourceMappingGroup :execrows
UPDATE resource_mapping_groups
SET
    namespace_id = COALESCE($2, namespace_id),
    name = COALESCE($3, name),
    metadata = COALESCE($4, metadata),
    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now', '+0.001 seconds')
WHERE id = $1
`

type UpdateResourceMappingGroupParams struct {
	ID          string         `json:"id"`
	NamespaceID sql.NullString `json:"namespace_id"`
	Name        sql.NullString `json:"name"`
	Metadata    sql.NullString `json:"metadata"`
}

// UpdateResourceMappingGroup
//
//	UPDATE resource_mapping_groups
//	SET
//	    namespace_id = COALESCE($2, namespace_id),
//	    name = COALESCE($3, name),
//	    metadata = COALESCE($4, metadata),
//	    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now', '+0.001 seconds')
//	WHERE id = $1
func (q *Queries) UpdateResourceMappingGroup(ctx context.Context, arg UpdateResourceMappingGroupParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateResourceMappingGroup,
		arg.ID,
		arg.NamespaceID,
		arg.Name,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
