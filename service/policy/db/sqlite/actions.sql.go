// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: actions.sql

package dbsqlite

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createCustomAction = `-- name: CreateCustomAction :one
INSERT INTO actions (id, name, metadata, is_standard, created_at, updated_at)
VALUES (
    gen_random_uuid(),
    $1,
    $2,
    FALSE,
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'),
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
)
RETURNING id
`

type CreateCustomActionParams struct {
	Name     string         `json:"name"`
	Metadata sql.NullString `json:"metadata"`
}

// CreateCustomAction
//
//	INSERT INTO actions (name, metadata, is_standard)
//	VALUES ($1, $2, FALSE)
//	RETURNING id
func (q *Queries) CreateCustomAction(ctx context.Context, arg CreateCustomActionParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createCustomAction, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createOrListActionsByName = `-- name: CreateOrListActionsByName :many
WITH input_actions AS (
    SELECT input.value AS name FROM json_each($1) AS input(value)
),
new_actions AS (
    INSERT INTO actions (id, name, is_standard, created_at, updated_at)
    SELECT 
        gen_random_uuid(),
        input.name,
        FALSE, -- custom actions
        STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'),
        STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
    FROM input_actions input
    WHERE NOT EXISTS (
        SELECT 1 FROM actions a WHERE LOWER(a.name) = LOWER(input.name)
    )
    RETURNING id, name, is_standard, created_at
),
all_actions AS (
    -- Get existing actions that match input names
    SELECT a.id, a.name, a.is_standard, a.created_at, 
           TRUE AS pre_existing
    FROM actions a
    JOIN input_actions input ON LOWER(a.name) = LOWER(input.name)
    
    UNION ALL
    
    -- Include newly created actions
    SELECT id, name, is_standard, created_at,
           FALSE AS pre_existing
    FROM new_actions
)
SELECT 
    id,
    name,
    is_standard,
    created_at,
    pre_existing
FROM all_actions
ORDER BY name
`

type CreateOrListActionsByNameRow struct {
	ID          string       `json:"id"`
	Name        string       `json:"name"`
	IsStandard  sql.NullBool `json:"is_standard"`
	CreatedAt   sql.NullTime `json:"created_at"`
	PreExisting bool         `json:"pre_existing"`
}

// CreateOrListActionsByName
//
//	WITH input_actions AS (
//	    SELECT input.value AS name FROM json_each($1) AS input(value)
//	),
//	new_actions AS (
//	    INSERT INTO actions (name, is_standard)
//	    SELECT
//	        input.name,
//	        FALSE -- custom actions
//	    FROM input_actions input
//	    WHERE NOT EXISTS (
//	        SELECT 1 FROM actions a WHERE LOWER(a.name) = LOWER(input.name)
//	    )
//	    ON CONFLICT (name) DO NOTHING
//	    RETURNING id, name, is_standard, created_at
//	),
//	all_actions AS (
//	    -- Get existing actions that match input names
//	    SELECT a.id, a.name, a.is_standard, a.created_at,
//	           TRUE AS pre_existing
//	    FROM actions a
//	    JOIN input_actions input ON LOWER(a.name) = LOWER(input.name)
//
//	    UNION ALL
//
//	    -- Include newly created actions
//	    SELECT id, name, is_standard, created_at,
//	           FALSE AS pre_existing
//	    FROM new_actions
//	)
//	SELECT
//	    id,
//	    name,
//	    is_standard,
//	    created_at,
//	    pre_existing
//	FROM all_actions
//	ORDER BY name
func (q *Queries) CreateOrListActionsByName(ctx context.Context, actionNames json.RawMessage) ([]CreateOrListActionsByNameRow, error) {
	rows, err := q.db.QueryContext(ctx, createOrListActionsByName, actionNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CreateOrListActionsByNameRow
	for rows.Next() {
		var i CreateOrListActionsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsStandard,
			&i.CreatedAt,
			&i.PreExisting,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteCustomAction = `-- name: DeleteCustomAction :execrows
DELETE FROM actions
WHERE id = $1
  AND is_standard = FALSE
`

// DeleteCustomAction
//
//	DELETE FROM actions
//	WHERE id = $1
//	  AND is_standard = FALSE
func (q *Queries) DeleteCustomAction(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteCustomAction, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAction = `-- name: GetAction :one
SELECT 
    a.id,
    a.name,
    a.is_standard,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(a.metadata, '$.labels'), 'created_at', a.created_at, 'updated_at', a.updated_at)) AS metadata
FROM actions a
WHERE 
  ($1 IS NULL OR a.id = $1)
  AND ($2 IS NULL OR a.name = $2)
`

type GetActionParams struct {
	ID   interface{} `json:"id"`
	Name interface{} `json:"name"`
}

type GetActionRow struct {
	ID         string          `json:"id"`
	Name       string          `json:"name"`
	IsStandard sql.NullBool    `json:"is_standard"`
	Metadata   json.RawMessage `json:"metadata"`
}

// GetAction
//
//	SELECT
//	    a.id,
//	    a.name,
//	    a.is_standard,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(a.metadata, '$.labels'), 'created_at', a.created_at, 'updated_at', a.updated_at)) AS metadata
//	FROM actions a
//	WHERE
//	  ($1 IS NULL OR a.id = $1)
//	  AND ($2 IS NULL OR a.name = $2)
func (q *Queries) GetAction(ctx context.Context, arg GetActionParams) (GetActionRow, error) {
	row := q.db.QueryRowContext(ctx, getAction, arg.ID, arg.Name)
	var i GetActionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsStandard,
		&i.Metadata,
	)
	return i, err
}

const listActions = `-- name: ListActions :many

WITH counted AS (
    SELECT COUNT(id) AS total FROM actions
)
SELECT 
    a.id,
    a.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
        'labels', json_extract(a.metadata, '$.labels'), 
        'created_at', a.created_at, 
        'updated_at', a.updated_at
    )) as metadata,
    a.is_standard,
    counted.total
FROM actions a
CROSS JOIN counted
ORDER BY a.created_at DESC
LIMIT $2 
OFFSET $1
`

type ListActionsParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type ListActionsRow struct {
	ID         string          `json:"id"`
	Name       string          `json:"name"`
	Metadata   json.RawMessage `json:"metadata"`
	IsStandard sql.NullBool    `json:"is_standard"`
	Total      int64           `json:"total"`
}

// --------------------------------------------------------------
// ACTIONS
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total FROM actions
//	)
//	SELECT
//	    a.id,
//	    a.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	        'labels', json_extract(a.metadata, '$.labels'),
//	        'created_at', a.created_at,
//	        'updated_at', a.updated_at
//	    )) as metadata,
//	    a.is_standard,
//	    counted.total
//	FROM actions a
//	CROSS JOIN counted
//	ORDER BY a.created_at DESC
//	LIMIT $2
//	OFFSET $1
func (q *Queries) ListActions(ctx context.Context, arg ListActionsParams) ([]ListActionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listActions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActionsRow
	for rows.Next() {
		var i ListActionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Metadata,
			&i.IsStandard,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomAction = `-- name: UpdateCustomAction :execrows
UPDATE actions
SET
    name = COALESCE($2, name),
    metadata = COALESCE($3, metadata),
    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now', '+0.001 seconds')
WHERE id = $1
  AND is_standard = FALSE
`

type UpdateCustomActionParams struct {
	ID       string         `json:"id"`
	Name     sql.NullString `json:"name"`
	Metadata sql.NullString `json:"metadata"`
}

// UpdateCustomAction
//
//	UPDATE actions
//	SET
//	    name = COALESCE($2, name),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
//	  AND is_standard = FALSE
func (q *Queries) UpdateCustomAction(ctx context.Context, arg UpdateCustomActionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateCustomAction, arg.ID, arg.Name, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
