// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attributes.sql

package dbsqlite

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/sqlc-dev/pqtype"
)

const assignPublicKeyToAttributeDefinition = `-- name: AssignPublicKeyToAttributeDefinition :one
INSERT INTO attribute_definition_public_key_map (definition_id, key_access_server_key_id)
VALUES ($1, $2)
RETURNING definition_id, key_access_server_key_id
`

type AssignPublicKeyToAttributeDefinitionParams struct {
	DefinitionID         sql.NullString `json:"definition_id"`
	KeyAccessServerKeyID sql.NullString `json:"key_access_server_key_id"`
}

// AssignPublicKeyToAttributeDefinition
//
//	INSERT INTO attribute_definition_public_key_map (definition_id, key_access_server_key_id)
//	VALUES ($1, $2)
//	RETURNING definition_id, key_access_server_key_id
func (q *Queries) AssignPublicKeyToAttributeDefinition(ctx context.Context, arg AssignPublicKeyToAttributeDefinitionParams) (AttributeDefinitionPublicKeyMap, error) {
	row := q.db.QueryRowContext(ctx, assignPublicKeyToAttributeDefinition, arg.DefinitionID, arg.KeyAccessServerKeyID)
	var i AttributeDefinitionPublicKeyMap
	err := row.Scan(&i.DefinitionID, &i.KeyAccessServerKeyID)
	return i, err
}

const createAttribute = `-- name: CreateAttribute :one
INSERT INTO attribute_definitions (id, namespace_id, name, rule, metadata, allow_traversal, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, $3, $4, $5, STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'), STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')) 
RETURNING id
`

type CreateAttributeParams struct {
	NamespaceID    sql.NullString `json:"namespace_id"`
	Name           string         `json:"name"`
	Rule           sql.NullString `json:"rule"`
	Metadata       sql.NullString `json:"metadata"`
	AllowTraversal sql.NullBool   `json:"allow_traversal"`
}

// CreateAttribute
//
//	INSERT INTO attribute_definitions (id, namespace_id, name, rule, metadata, allow_traversal, created_at, updated_at)
//	VALUES (gen_random_uuid(), $1, $2, $3, $4, $5, STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'), STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'))
//	RETURNING id
func (q *Queries) CreateAttribute(ctx context.Context, arg CreateAttributeParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createAttribute,
		arg.NamespaceID,
		arg.Name,
		arg.Rule,
		arg.Metadata,
		arg.AllowTraversal,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAttribute = `-- name: DeleteAttribute :execrows
DELETE FROM attribute_definitions WHERE id = $1
`

// DeleteAttribute
//
//	DELETE FROM attribute_definitions WHERE id = $1
func (q *Queries) DeleteAttribute(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAttribute, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAttribute = `-- name: GetAttribute :one
SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    ad.allow_traversal,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(ad.metadata, '$.labels'), 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name,
    COALESCE(JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', avt.id,
            'value', avt.value,
            'active', avt.active,
            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
    ), JSON_BUILD_ARRAY()) AS "values",
    COALESCE(JSON_AGG(
        DISTINCT CASE
            WHEN adkag.attribute_definition_id IS NOT NULL THEN JSON_BUILD_OBJECT(
                'id', kas.id,
                'uri', kas.uri,
                'name', kas.name,
                'public_key', kas.public_key
            )
        END
    ), JSON_BUILD_ARRAY()) AS grants,
    fqns.fqn,
    COALESCE(defk.keys, JSON_BUILD_ARRAY()) as keys
FROM attribute_definitions ad
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
LEFT JOIN (
    SELECT
        av.id,
        av.value,
        av.active,
        av.attribute_definition_id
    FROM attribute_values av
    GROUP BY av.id
) avt ON avt.attribute_definition_id = ad.id
LEFT JOIN attribute_definition_key_access_grants adkag ON adkag.attribute_definition_id = ad.id
LEFT JOIN key_access_servers kas ON kas.id = adkag.key_access_server_id
LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
LEFT JOIN (
    SELECT
        k.definition_id,
        JSON_AGG(
            DISTINCT CASE
                WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'kas_uri', kas.uri,
                    'kas_id', kas.id,
                    'public_key', JSON_BUILD_OBJECT(
                         'algorithm', kask.key_algorithm,
                         'kid', kask.key_id,
                         'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
                    )
                )
            END
        ) AS keys
    FROM attribute_definition_public_key_map k
    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
    GROUP BY k.definition_id
) defk ON ad.id = defk.definition_id
WHERE ($1 IS NULL OR ad.id = $1)
  AND ($2 IS NULL OR REGEXP_REPLACE(fqns.fqn, '^https://', '') = REGEXP_REPLACE($2, '^https://', ''))
GROUP BY ad.id, n.name, fqns.fqn, defk.keys
`

type GetAttributeParams struct {
	ID  interface{} `json:"id"`
	Fqn interface{} `json:"fqn"`
}

type GetAttributeRow struct {
	ID             string          `json:"id"`
	AttributeName  string          `json:"attribute_name"`
	Rule           sql.NullString  `json:"rule"`
	AllowTraversal sql.NullBool    `json:"allow_traversal"`
	Metadata       json.RawMessage `json:"metadata"`
	NamespaceID    sql.NullString  `json:"namespace_id"`
	Active         sql.NullBool    `json:"active"`
	NamespaceName  sql.NullString  `json:"namespace_name"`
	Values         json.RawMessage `json:"values"`
	Grants         json.RawMessage `json:"grants"`
	Fqn            sql.NullString  `json:"fqn"`
	Keys           json.RawMessage `json:"keys"`
}

// GetAttribute
//
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    ad.allow_traversal,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(ad.metadata, '$.labels'), 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', avt.id,
//	            'value', avt.value,
//	            'active', avt.active,
//	            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
//	        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
//	    ) AS values,
//	    JSON_AGG(
//	        DISTINCT CASE
//	            WHEN adkag.attribute_definition_id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                'id', kas.id,
//	                'uri', kas.uri,
//	                'name', kas.name,
//	                'public_key', kas.public_key
//	            )
//	        END
//	    ) AS grants,
//	    fqns.fqn,
//	    defk.keys as keys
//	FROM attribute_definitions ad
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	LEFT JOIN (
//	    SELECT
//	        av.id,
//	        av.value,
//	        av.active,
//	        av.attribute_definition_id
//	    FROM attribute_values av
//	    GROUP BY av.id
//	) avt ON avt.attribute_definition_id = ad.id
//	LEFT JOIN attribute_definition_key_access_grants adkag ON adkag.attribute_definition_id = ad.id
//	LEFT JOIN key_access_servers kas ON kas.id = adkag.key_access_server_id
//	LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
//	LEFT JOIN (
//	    SELECT
//	        k.definition_id,
//	        JSON_AGG(
//	            DISTINCT CASE
//	                WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'kas_uri', kas.uri,
//	                    'kas_id', kas.id,
//	                    'public_key', JSON_BUILD_OBJECT(
//	                         'algorithm', kask.key_algorithm,
//	                         'kid', kask.key_id,
//	                         'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
//	                    )
//	                )
//	            END
//	        ) AS keys
//	    FROM attribute_definition_public_key_map k
//	    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	    GROUP BY k.definition_id
//	) defk ON ad.id = defk.definition_id
//	WHERE ($1 IS NULL OR ad.id = $1)
//	  AND ($2 IS NULL OR REGEXP_REPLACE(fqns.fqn, '^https://', '') = REGEXP_REPLACE($2, '^https://', ''))
//	GROUP BY ad.id, n.name, fqns.fqn, defk.keys
func (q *Queries) GetAttribute(ctx context.Context, arg GetAttributeParams) (GetAttributeRow, error) {
	row := q.db.QueryRowContext(ctx, getAttribute, arg.ID, arg.Fqn)
	var i GetAttributeRow
	err := row.Scan(
		&i.ID,
		&i.AttributeName,
		&i.Rule,
		&i.AllowTraversal,
		&i.Metadata,
		&i.NamespaceID,
		&i.Active,
		&i.NamespaceName,
		&i.Values,
		&i.Grants,
		&i.Fqn,
		&i.Keys,
	)
	return i, err
}

const listAttributesByDefOrValueFqns = `-- name: ListAttributesByDefOrValueFqns :many
WITH target_definition AS (
    SELECT DISTINCT
        ad.id,
        ad.namespace_id,
        ad.name,
        ad.rule,
        ad.allow_traversal,
        ad.active,
        ad.values_order,
        ad.created_at,
        JSON_AGG(
            DISTINCT CASE
                WHEN kas.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'id', kas.id,
                    'uri', kas.uri,
                    'name', kas.name,
                    'public_key', kas.public_key
                )
            END
        ) AS grants,
        defk.keys AS keys
    FROM attribute_fqns fqns
    INNER JOIN attribute_definitions ad ON fqns.attribute_id = ad.id
    LEFT JOIN attribute_definition_key_access_grants adkag ON ad.id = adkag.attribute_definition_id
    LEFT JOIN key_access_servers kas ON adkag.key_access_server_id = kas.id
    LEFT JOIN (
        SELECT
            k.definition_id,
            JSON_AGG(
                DISTINCT CASE
                    WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                        'kas_uri', kas.uri,
                        'kas_id', kas.id,
                        'public_key', JSON_BUILD_OBJECT(
                             'algorithm', kask.key_algorithm,
                             'kid', kask.key_id,
                             'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
                        )
                    )
                END
            ) AS keys
        FROM attribute_definition_public_key_map k
        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
        GROUP BY k.definition_id
    ) defk ON ad.id = defk.definition_id
    WHERE fqns.fqn IN (SELECT fqns_vals.value FROM json_each($1) AS fqns_vals(value)) 
        AND ad.active = TRUE
    GROUP BY ad.id, ad.created_at, defk.keys
),
namespaces AS (
	SELECT
		n.id,
		JSON_BUILD_OBJECT(
			'id', n.id,
			'name', n.name,
			'active', n.active,
	        'fqn', fqns.fqn,
            'grants', JSON_AGG(
                DISTINCT CASE
                    WHEN kas.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                        'id', kas.id,
                        'uri', kas.uri,
                        'name', kas.name,
                        'public_key', kas.public_key
                    )
                END
            ),
            'kas_keys', nmp_keys.keys
    	) AS namespace
	FROM target_definition td
	INNER JOIN attribute_namespaces n ON td.namespace_id = n.id
	INNER JOIN attribute_fqns fqns ON n.id = fqns.namespace_id
    LEFT JOIN attribute_namespace_key_access_grants ankag ON n.id = ankag.namespace_id
	LEFT JOIN key_access_servers kas ON ankag.key_access_server_id = kas.id
    LEFT JOIN (
        SELECT
            k.namespace_id,
            JSON_AGG(
                DISTINCT CASE
                    WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                        'kas_uri', kas.uri,
                        'kas_id', kas.id,
                        'public_key', JSON_BUILD_OBJECT(
                             'algorithm', kask.key_algorithm,
                             'kid', kask.key_id,
                             'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
                        )
                    )
                END
            ) AS keys
        FROM attribute_namespace_public_key_map k
        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
        GROUP BY k.namespace_id
    ) nmp_keys ON n.id = nmp_keys.namespace_id
	WHERE n.active = TRUE
		AND (fqns.attribute_id IS NULL AND fqns.value_id IS NULL)
	GROUP BY n.id, fqns.fqn, nmp_keys.keys
),
value_grants AS (
	SELECT
		av.id,
        JSON_AGG(
            DISTINCT CASE
                WHEN kas.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'id', kas.id,
                    'uri', kas.uri,
                    'name', kas.name,
                    'public_key', kas.public_key
                )
            END
        ) AS grants
	FROM target_definition td
	LEFT JOIN attribute_values av on td.id = av.attribute_definition_id
	LEFT JOIN attribute_value_key_access_grants avkag ON av.id = avkag.attribute_value_id
	LEFT JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
	GROUP BY av.id
),
value_subject_mappings AS (
	SELECT
		av.id,
        JSON_AGG(
            CASE
                WHEN sm.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'id', sm.id,
                    'actions', (
                        SELECT COALESCE(
                            JSON_AGG(
                                CASE
                                    WHEN a.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                                        'id', a.id,
                                        'name', a.name
                                    )
                                END
                            ),
                            '[]'
                        )
                        FROM subject_mapping_actions sma
                        LEFT JOIN actions a ON sma.action_id = a.id
                        WHERE sma.subject_mapping_id = sm.id
                    ),
                    'subject_condition_set', JSON_BUILD_OBJECT(
                        'id', scs.id,
                        'subject_sets', scs.condition
                    )
                )
            END
        ) AS sub_maps
	FROM target_definition td
	LEFT JOIN attribute_values av ON td.id = av.attribute_definition_id
	LEFT JOIN subject_mappings sm ON av.id = sm.attribute_value_id
	LEFT JOIN subject_condition_set scs ON sm.subject_condition_set_id = scs.id
	GROUP BY av.id
),
value_resource_mappings AS (
    SELECT
        av.id,
        JSON_AGG(
            CASE
                WHEN rm.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'id', rm.id,
                    'terms', rm.terms,
                    'group', CASE 
                                WHEN rm.group_id IS NULL THEN NULL
                                ELSE JSON_BUILD_OBJECT(
                                    'id', rmg.id,
                                    'name', rmg.name,
                                    'namespace_id', rmg.namespace_id
                                )
                             END
                )
            END
        ) AS res_maps
    FROM target_definition td
    LEFT JOIN attribute_values av ON td.id = av.attribute_definition_id
    LEFT JOIN resource_mappings rm ON av.id = rm.attribute_value_id
    LEFT JOIN resource_mapping_groups rmg ON rm.group_id = rmg.id
    GROUP BY av.id
),
"values" AS (
    SELECT
		av.attribute_definition_id,
		JSON_AGG(
	        JSON_BUILD_OBJECT(
	            'id', av.id,
	            'value', av.value,
	            'active', av.active,
	            'fqn', fqns.fqn,
                'grants', avg.grants,
	            'subject_mappings', avsm.sub_maps,
                'resource_mappings', avrm.res_maps,
                'kas_keys', value_keys.keys
	        -- enforce order of values in response
	        ) ORDER BY ARRAY_POSITION(td.values_order, av.id)
	    ) AS "values"
	FROM target_definition td
	LEFT JOIN attribute_values av ON td.id = av.attribute_definition_id
	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
    LEFT JOIN value_grants avg ON av.id = avg.id
	LEFT JOIN value_subject_mappings avsm ON av.id = avsm.id
    LEFT JOIN value_resource_mappings avrm ON av.id = avrm.id
    LEFT JOIN (
        SELECT
            k.value_id,
            JSON_AGG(
                DISTINCT CASE
                    WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                        'kas_uri', kas.uri,
                        'kas_id', kas.id,
                        'public_key', JSON_BUILD_OBJECT(
                             'algorithm', kask.key_algorithm,
                             'kid', kask.key_id,
                             'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
                        )
                    )
                END
            ) AS keys
        FROM attribute_value_public_key_map k
        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
        GROUP BY k.value_id
    ) value_keys ON av.id = value_keys.value_id                        
	WHERE (av.active = TRUE OR $2 = TRUE)
	GROUP BY av.attribute_definition_id
)
SELECT
	td.id,
	td.name,
    td.rule,
    td.allow_traversal,
	td.active,
	n.namespace,
	fqns.fqn,
	"values"."values",
    td.grants,
    td.keys
FROM target_definition td
INNER JOIN attribute_fqns fqns ON td.id = fqns.attribute_id
INNER JOIN namespaces n ON td.namespace_id = n.id
LEFT JOIN "values" ON td.id = "values".attribute_definition_id
WHERE fqns.value_id IS NULL
ORDER BY td.created_at DESC
`

type ListAttributesByDefOrValueFqnsParams struct {
	Fqns                  json.RawMessage `json:"fqns"`
	IncludeInactiveValues interface{}     `json:"include_inactive_values"`
}

type ListAttributesByDefOrValueFqnsRow struct {
	ID             string                `json:"id"`
	Name           string                `json:"name"`
	Rule           sql.NullString        `json:"rule"`
	AllowTraversal sql.NullBool          `json:"allow_traversal"`
	Active         sql.NullBool          `json:"active"`
	Namespace      json.RawMessage       `json:"namespace"`
	Fqn            string                `json:"fqn"`
	Values         pqtype.NullRawMessage `json:"values"`
	Grants         json.RawMessage       `json:"grants"`
	Keys           json.RawMessage       `json:"keys"`
}

// get the attribute definition for the provided value or definition fqn
//
//	WITH target_definition AS (
//	    SELECT DISTINCT
//	        ad.id,
//	        ad.namespace_id,
//	        ad.name,
//	        ad.rule,
//	        ad.allow_traversal,
//	        ad.active,
//	        ad.values_order,
//	        ad.created_at,
//	        JSON_AGG(
//	            DISTINCT CASE
//	                WHEN kas.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'id', kas.id,
//	                    'uri', kas.uri,
//	                    'name', kas.name,
//	                    'public_key', kas.public_key
//	                )
//	            END
//	        ) AS grants,
//	        defk.keys AS keys
//	    FROM attribute_fqns fqns
//	    INNER JOIN attribute_definitions ad ON fqns.attribute_id = ad.id
//	    LEFT JOIN attribute_definition_key_access_grants adkag ON ad.id = adkag.attribute_definition_id
//	    LEFT JOIN key_access_servers kas ON adkag.key_access_server_id = kas.id
//	    LEFT JOIN (
//	        SELECT
//	            k.definition_id,
//	            JSON_AGG(
//	                DISTINCT CASE
//	                    WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                        'kas_uri', kas.uri,
//	                        'kas_id', kas.id,
//	                        'public_key', JSON_BUILD_OBJECT(
//	                             'algorithm', kask.key_algorithm,
//	                             'kid', kask.key_id,
//	                             'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
//	                        )
//	                    )
//	                END
//	            ) AS keys
//	        FROM attribute_definition_public_key_map k
//	        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	        GROUP BY k.definition_id
//	    ) defk ON ad.id = defk.definition_id
//	    WHERE fqns.fqn IN (SELECT fqns_vals.value FROM json_each($1) AS fqns_vals(value))
//	        AND ad.active = TRUE
//	    GROUP BY ad.id, ad.created_at, defk.keys
//	),
//	namespaces AS (
//		SELECT
//			n.id,
//			JSON_BUILD_OBJECT(
//				'id', n.id,
//				'name', n.name,
//				'active', n.active,
//		        'fqn', fqns.fqn,
//	            'grants', JSON_AGG(
//	                DISTINCT CASE
//	                    WHEN kas.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                        'id', kas.id,
//	                        'uri', kas.uri,
//	                        'name', kas.name,
//	                        'public_key', kas.public_key
//	                    )
//	                END
//	            ),
//	            'kas_keys', nmp_keys.keys
//	    	) AS namespace
//		FROM target_definition td
//		INNER JOIN attribute_namespaces n ON td.namespace_id = n.id
//		INNER JOIN attribute_fqns fqns ON n.id = fqns.namespace_id
//	    LEFT JOIN attribute_namespace_key_access_grants ankag ON n.id = ankag.namespace_id
//		LEFT JOIN key_access_servers kas ON ankag.key_access_server_id = kas.id
//	    LEFT JOIN (
//	        SELECT
//	            k.namespace_id,
//	            JSON_AGG(
//	                DISTINCT CASE
//	                    WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                        'kas_uri', kas.uri,
//	                        'kas_id', kas.id,
//	                        'public_key', JSON_BUILD_OBJECT(
//	                             'algorithm', kask.key_algorithm,
//	                             'kid', kask.key_id,
//	                             'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
//	                        )
//	                    )
//	                END
//	            ) AS keys
//	        FROM attribute_namespace_public_key_map k
//	        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	        GROUP BY k.namespace_id
//	    ) nmp_keys ON n.id = nmp_keys.namespace_id
//		WHERE n.active = TRUE
//			AND (fqns.attribute_id IS NULL AND fqns.value_id IS NULL)
//		GROUP BY n.id, fqns.fqn, nmp_keys.keys
//	),
//	value_grants AS (
//		SELECT
//			av.id,
//	        JSON_AGG(
//	            DISTINCT CASE
//	                WHEN kas.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'id', kas.id,
//	                    'uri', kas.uri,
//	                    'name', kas.name,
//	                    'public_key', kas.public_key
//	                )
//	            END
//	        ) AS grants
//		FROM target_definition td
//		LEFT JOIN attribute_values av on td.id = av.attribute_definition_id
//		LEFT JOIN attribute_value_key_access_grants avkag ON av.id = avkag.attribute_value_id
//		LEFT JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
//		GROUP BY av.id
//	),
//	value_subject_mappings AS (
//		SELECT
//			av.id,
//	        JSON_AGG(
//	            CASE
//	                WHEN sm.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'id', sm.id,
//	                    'actions', (
//	                        SELECT COALESCE(
//	                            JSON_AGG(
//	                                CASE
//	                                    WHEN a.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                                        'id', a.id,
//	                                        'name', a.name
//	                                    )
//	                                END
//	                            ),
//	                            '[]'
//	                        )
//	                        FROM subject_mapping_actions sma
//	                        LEFT JOIN actions a ON sma.action_id = a.id
//	                        WHERE sma.subject_mapping_id = sm.id
//	                    ),
//	                    'subject_condition_set', JSON_BUILD_OBJECT(
//	                        'id', scs.id,
//	                        'subject_sets', scs.condition
//	                    )
//	                )
//	            END
//	        ) AS sub_maps
//		FROM target_definition td
//		LEFT JOIN attribute_values av ON td.id = av.attribute_definition_id
//		LEFT JOIN subject_mappings sm ON av.id = sm.attribute_value_id
//		LEFT JOIN subject_condition_set scs ON sm.subject_condition_set_id = scs.id
//		GROUP BY av.id
//	),
//	value_resource_mappings AS (
//	    SELECT
//	        av.id,
//	        JSON_AGG(
//	            CASE
//	                WHEN rm.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'id', rm.id,
//	                    'terms', rm.terms,
//	                    'group', CASE
//	                                WHEN rm.group_id IS NULL THEN NULL
//	                                ELSE JSON_BUILD_OBJECT(
//	                                    'id', rmg.id,
//	                                    'name', rmg.name,
//	                                    'namespace_id', rmg.namespace_id
//	                                )
//	                             END
//	                )
//	            END
//	        ) AS res_maps
//	    FROM target_definition td
//	    LEFT JOIN attribute_values av ON td.id = av.attribute_definition_id
//	    LEFT JOIN resource_mappings rm ON av.id = rm.attribute_value_id
//	    LEFT JOIN resource_mapping_groups rmg ON rm.group_id = rmg.id
//	    GROUP BY av.id
//	),
//	values AS (
//	    SELECT
//			av.attribute_definition_id,
//			JSON_AGG(
//		        JSON_BUILD_OBJECT(
//		            'id', av.id,
//		            'value', av.value,
//		            'active', av.active,
//		            'fqn', fqns.fqn,
//	                'grants', avg.grants,
//		            'subject_mappings', avsm.sub_maps,
//	                'resource_mappings', avrm.res_maps,
//	                'kas_keys', value_keys.keys
//		        -- enforce order of values in response
//		        ) ORDER BY ARRAY_POSITION(td.values_order, av.id)
//		    ) AS values
//		FROM target_definition td
//		LEFT JOIN attribute_values av ON td.id = av.attribute_definition_id
//		LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	    LEFT JOIN value_grants avg ON av.id = avg.id
//		LEFT JOIN value_subject_mappings avsm ON av.id = avsm.id
//	    LEFT JOIN value_resource_mappings avrm ON av.id = avrm.id
//	    LEFT JOIN (
//	        SELECT
//	            k.value_id,
//	            JSON_AGG(
//	                DISTINCT CASE
//	                    WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                        'kas_uri', kas.uri,
//	                        'kas_id', kas.id,
//	                        'public_key', JSON_BUILD_OBJECT(
//	                             'algorithm', kask.key_algorithm,
//	                             'kid', kask.key_id,
//	                             'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
//	                        )
//	                    )
//	                END
//	            ) AS keys
//	        FROM attribute_value_public_key_map k
//	        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	        GROUP BY k.value_id
//	    ) value_keys ON av.id = value_keys.value_id
//		WHERE (av.active = TRUE OR $2 = TRUE)
//		GROUP BY av.attribute_definition_id
//	)
//	SELECT
//		td.id,
//		td.name,
//	    td.rule,
//	    td.allow_traversal,
//		td.active,
//		n.namespace,
//		fqns.fqn,
//		values.values,
//	    td.grants,
//	    td.keys
//	FROM target_definition td
//	INNER JOIN attribute_fqns fqns ON td.id = fqns.attribute_id
//	INNER JOIN namespaces n ON td.namespace_id = n.id
//	LEFT JOIN values ON td.id = values.attribute_definition_id
//	WHERE fqns.value_id IS NULL
//	ORDER BY td.created_at DESC
func (q *Queries) ListAttributesByDefOrValueFqns(ctx context.Context, arg ListAttributesByDefOrValueFqnsParams) ([]ListAttributesByDefOrValueFqnsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttributesByDefOrValueFqns, arg.Fqns, arg.IncludeInactiveValues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttributesByDefOrValueFqnsRow
	for rows.Next() {
		var i ListAttributesByDefOrValueFqnsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Rule,
			&i.AllowTraversal,
			&i.Active,
			&i.Namespace,
			&i.Fqn,
			&i.Values,
			&i.Grants,
			&i.Keys,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributesDetail = `-- name: ListAttributesDetail :many

SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    ad.allow_traversal,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(ad.metadata, '$.labels'), 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', avt.id,
            'value', avt.value,
            'active', avt.active,
            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
    ) AS "values",
    fqns.fqn,
    COUNT(*) OVER() AS total
FROM attribute_definitions ad
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
LEFT JOIN (
  SELECT
    av.id,
    av.value,
    av.active,
    av.attribute_definition_id
  FROM attribute_values av
  GROUP BY av.id
) avt ON avt.attribute_definition_id = ad.id
LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
WHERE
    ($1 IS NULL OR ad.active = $1) AND
    ($2 IS NULL OR ad.namespace_id = $2) AND 
    ($3 IS NULL OR n.name = $3) 
GROUP BY ad.id, n.name, fqns.fqn
ORDER BY ad.created_at DESC
LIMIT $5 
OFFSET $4
`

type ListAttributesDetailParams struct {
	Active        interface{} `json:"active"`
	NamespaceID   interface{} `json:"namespace_id"`
	NamespaceName interface{} `json:"namespace_name"`
	Offset        int32       `json:"offset_"`
	Limit         int32       `json:"limit_"`
}

type ListAttributesDetailRow struct {
	ID             string          `json:"id"`
	AttributeName  string          `json:"attribute_name"`
	Rule           sql.NullString  `json:"rule"`
	AllowTraversal sql.NullBool    `json:"allow_traversal"`
	Metadata       json.RawMessage `json:"metadata"`
	NamespaceID    sql.NullString  `json:"namespace_id"`
	Active         sql.NullBool    `json:"active"`
	NamespaceName  sql.NullString  `json:"namespace_name"`
	Values         json.RawMessage `json:"values"`
	Fqn            sql.NullString  `json:"fqn"`
	Total          int64           `json:"total"`
}

// --------------------------------------------------------------
// ATTRIBUTES
// --------------------------------------------------------------
//
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    ad.allow_traversal,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(ad.metadata, '$.labels'), 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', avt.id,
//	            'value', avt.value,
//	            'active', avt.active,
//	            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
//	        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
//	    ) AS values,
//	    fqns.fqn,
//	    COUNT(*) OVER() AS total
//	FROM attribute_definitions ad
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	LEFT JOIN (
//	  SELECT
//	    av.id,
//	    av.value,
//	    av.active,
//	    av.attribute_definition_id
//	  FROM attribute_values av
//	  GROUP BY av.id
//	) avt ON avt.attribute_definition_id = ad.id
//	LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
//	WHERE
//	    ($1 IS NULL OR ad.active = $1) AND
//	    ($2 IS NULL OR ad.namespace_id = $2) AND
//	    ($3 IS NULL OR n.name = $3)
//	GROUP BY ad.id, n.name, fqns.fqn
//	ORDER BY ad.created_at DESC
//	LIMIT $5
//	OFFSET $4
func (q *Queries) ListAttributesDetail(ctx context.Context, arg ListAttributesDetailParams) ([]ListAttributesDetailRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttributesDetail,
		arg.Active,
		arg.NamespaceID,
		arg.NamespaceName,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttributesDetailRow
	for rows.Next() {
		var i ListAttributesDetailRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeName,
			&i.Rule,
			&i.AllowTraversal,
			&i.Metadata,
			&i.NamespaceID,
			&i.Active,
			&i.NamespaceName,
			&i.Values,
			&i.Fqn,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributesSummary = `-- name: ListAttributesSummary :many
SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    ad.allow_traversal,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(ad.metadata, '$.labels'), 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name,
    COUNT(*) OVER() AS total
FROM attribute_definitions ad
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
WHERE ad.namespace_id = $1
GROUP BY ad.id, n.name
ORDER BY ad.created_at DESC
LIMIT $3 
OFFSET $2
`

type ListAttributesSummaryParams struct {
	NamespaceID sql.NullString `json:"namespace_id"`
	Offset      int32          `json:"offset_"`
	Limit       int32          `json:"limit_"`
}

type ListAttributesSummaryRow struct {
	ID             string          `json:"id"`
	AttributeName  string          `json:"attribute_name"`
	Rule           sql.NullString  `json:"rule"`
	AllowTraversal sql.NullBool    `json:"allow_traversal"`
	Metadata       json.RawMessage `json:"metadata"`
	NamespaceID    sql.NullString  `json:"namespace_id"`
	Active         sql.NullBool    `json:"active"`
	NamespaceName  sql.NullString  `json:"namespace_name"`
	Total          int64           `json:"total"`
}

// ListAttributesSummary
//
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    ad.allow_traversal,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(ad.metadata, '$.labels'), 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name,
//	    COUNT(*) OVER() AS total
//	FROM attribute_definitions ad
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	WHERE ad.namespace_id = $1
//	GROUP BY ad.id, n.name
//	ORDER BY ad.created_at DESC
//	LIMIT $3
//	OFFSET $2
func (q *Queries) ListAttributesSummary(ctx context.Context, arg ListAttributesSummaryParams) ([]ListAttributesSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttributesSummary, arg.NamespaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttributesSummaryRow
	for rows.Next() {
		var i ListAttributesSummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeName,
			&i.Rule,
			&i.AllowTraversal,
			&i.Metadata,
			&i.NamespaceID,
			&i.Active,
			&i.NamespaceName,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeKeyAccessServerFromAttribute = `-- name: RemoveKeyAccessServerFromAttribute :execrows
DELETE FROM attribute_definition_key_access_grants
WHERE attribute_definition_id = $1 AND key_access_server_id = $2
`

type RemoveKeyAccessServerFromAttributeParams struct {
	AttributeDefinitionID sql.NullString `json:"attribute_definition_id"`
	KeyAccessServerID     sql.NullString `json:"key_access_server_id"`
}

// RemoveKeyAccessServerFromAttribute
//
//	DELETE FROM attribute_definition_key_access_grants
//	WHERE attribute_definition_id = $1 AND key_access_server_id = $2
func (q *Queries) RemoveKeyAccessServerFromAttribute(ctx context.Context, arg RemoveKeyAccessServerFromAttributeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeKeyAccessServerFromAttribute, arg.AttributeDefinitionID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const removePublicKeyFromAttributeDefinition = `-- name: RemovePublicKeyFromAttributeDefinition :execrows
DELETE FROM attribute_definition_public_key_map
WHERE definition_id = $1 AND key_access_server_key_id = $2
`

type RemovePublicKeyFromAttributeDefinitionParams struct {
	DefinitionID         sql.NullString `json:"definition_id"`
	KeyAccessServerKeyID sql.NullString `json:"key_access_server_key_id"`
}

// RemovePublicKeyFromAttributeDefinition
//
//	DELETE FROM attribute_definition_public_key_map
//	WHERE definition_id = $1 AND key_access_server_key_id = $2
func (q *Queries) RemovePublicKeyFromAttributeDefinition(ctx context.Context, arg RemovePublicKeyFromAttributeDefinitionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removePublicKeyFromAttributeDefinition, arg.DefinitionID, arg.KeyAccessServerKeyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const rotatePublicKeyForAttributeDefinition = `-- name: RotatePublicKeyForAttributeDefinition :many
UPDATE attribute_definition_public_key_map
SET key_access_server_key_id = $1
WHERE (key_access_server_key_id = $2)
RETURNING definition_id
`

type RotatePublicKeyForAttributeDefinitionParams struct {
	NewKeyID sql.NullString `json:"new_key_id"`
	OldKeyID sql.NullString `json:"old_key_id"`
}

// RotatePublicKeyForAttributeDefinition
//
//	UPDATE attribute_definition_public_key_map
//	SET key_access_server_key_id = $1
//	WHERE (key_access_server_key_id = $2)
//	RETURNING definition_id
func (q *Queries) RotatePublicKeyForAttributeDefinition(ctx context.Context, arg RotatePublicKeyForAttributeDefinitionParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, rotatePublicKeyForAttributeDefinition, arg.NewKeyID, arg.OldKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var definition_id sql.NullString
		if err := rows.Scan(&definition_id); err != nil {
			return nil, err
		}
		items = append(items, definition_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAttribute = `-- name: UpdateAttribute :execrows
UPDATE attribute_definitions
SET
    name = COALESCE($2, name),
    rule = COALESCE($3, rule),
    values_order = COALESCE($4, values_order),
    metadata = COALESCE($5, metadata),
    active = COALESCE($6, active),
    allow_traversal = COALESCE($7, allow_traversal),
    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = $1
`

type UpdateAttributeParams struct {
	ID             string         `json:"id"`
	Name           sql.NullString `json:"name"`
	Rule           sql.NullString `json:"rule"`
	ValuesOrder    sql.NullString `json:"values_order"`
	Metadata       sql.NullString `json:"metadata"`
	Active         sql.NullBool   `json:"active"`
	AllowTraversal sql.NullBool   `json:"allow_traversal"`
}

// updateAttribute: Unsafe and Safe Updates both
//
//	UPDATE attribute_definitions
//	SET
//	    name = COALESCE($2, name),
//	    rule = COALESCE($3, rule),
//	    values_order = COALESCE($4, values_order),
//	    metadata = COALESCE($5, metadata),
//	    active = COALESCE($6, active),
//	    allow_traversal = COALESCE($7, allow_traversal),
//	    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
//	WHERE id = $1
func (q *Queries) UpdateAttribute(ctx context.Context, arg UpdateAttributeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAttribute,
		arg.ID,
		arg.Name,
		arg.Rule,
		arg.ValuesOrder,
		arg.Metadata,
		arg.Active,
		arg.AllowTraversal,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
