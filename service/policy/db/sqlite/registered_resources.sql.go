// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: registered_resources.sql

package dbsqlite

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createRegisteredResource = `-- name: CreateRegisteredResource :one

INSERT INTO registered_resources (id, name, metadata, created_at, updated_at)
VALUES (
    gen_random_uuid(),
    $1,
    $2,
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'),
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
)
RETURNING id
`

type CreateRegisteredResourceParams struct {
	Name     string         `json:"name"`
	Metadata sql.NullString `json:"metadata"`
}

// --------------------------------------------------------------
// REGISTERED RESOURCES
// --------------------------------------------------------------
//
//	INSERT INTO registered_resources (name, metadata)
//	VALUES ($1, $2)
//	RETURNING id
func (q *Queries) CreateRegisteredResource(ctx context.Context, arg CreateRegisteredResourceParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createRegisteredResource, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createRegisteredResourceActionAttributeValues = `-- name: CreateRegisteredResourceActionAttributeValues :exec

INSERT INTO registered_resource_action_attribute_values (
    id,
    registered_resource_value_id,
    action_id,
    attribute_value_id,
    created_at,
    updated_at
)
VALUES (
    gen_random_uuid(),
    $1,
    $2,
    $3,
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'),
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
)
`

type CreateRegisteredResourceActionAttributeValuesParams struct {
	RegisteredResourceValueID sql.NullString `json:"registered_resource_value_id"`
	ActionID                  sql.NullString `json:"action_id"`
	AttributeValueID          sql.NullString `json:"attribute_value_id"`
}

// --------------------------------------------------------------
// Registered Resource Action Attribute Values
// --------------------------------------------------------------
//
//	INSERT INTO registered_resource_action_attribute_values (registered_resource_value_id, action_id, attribute_value_id)
//	VALUES ($1, $2, $3)
func (q *Queries) CreateRegisteredResourceActionAttributeValues(ctx context.Context, arg CreateRegisteredResourceActionAttributeValuesParams) error {
	_, err := q.db.ExecContext(ctx, createRegisteredResourceActionAttributeValues, arg.RegisteredResourceValueID, arg.ActionID, arg.AttributeValueID)
	return err
}

const createRegisteredResourceValue = `-- name: CreateRegisteredResourceValue :one

INSERT INTO registered_resource_values (id, registered_resource_id, value, metadata, created_at, updated_at)
VALUES (
    gen_random_uuid(),
    $1,
    $2,
    $3,
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'),
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
)
RETURNING id
`

type CreateRegisteredResourceValueParams struct {
	RegisteredResourceID sql.NullString `json:"registered_resource_id"`
	Value                string         `json:"value"`
	Metadata             sql.NullString `json:"metadata"`
}

// --------------------------------------------------------------
// REGISTERED RESOURCE VALUES
// --------------------------------------------------------------
//
//	INSERT INTO registered_resource_values (registered_resource_id, value, metadata)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) CreateRegisteredResourceValue(ctx context.Context, arg CreateRegisteredResourceValueParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createRegisteredResourceValue, arg.RegisteredResourceID, arg.Value, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteRegisteredResource = `-- name: DeleteRegisteredResource :execrows
DELETE FROM registered_resources WHERE id = $1
`

// DeleteRegisteredResource
//
//	DELETE FROM registered_resources WHERE id = $1
func (q *Queries) DeleteRegisteredResource(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteRegisteredResource, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteRegisteredResourceActionAttributeValues = `-- name: DeleteRegisteredResourceActionAttributeValues :execrows
DELETE FROM registered_resource_action_attribute_values
WHERE registered_resource_value_id = $1
`

// DeleteRegisteredResourceActionAttributeValues
//
//	DELETE FROM registered_resource_action_attribute_values
//	WHERE registered_resource_value_id = $1
func (q *Queries) DeleteRegisteredResourceActionAttributeValues(ctx context.Context, registeredResourceValueID sql.NullString) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteRegisteredResourceActionAttributeValues, registeredResourceValueID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteRegisteredResourceValue = `-- name: DeleteRegisteredResourceValue :execrows
DELETE FROM registered_resource_values WHERE id = $1
`

// DeleteRegisteredResourceValue
//
//	DELETE FROM registered_resource_values WHERE id = $1
func (q *Queries) DeleteRegisteredResourceValue(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteRegisteredResourceValue, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getRegisteredResource = `-- name: GetRegisteredResource :one
SELECT
    r.id,
    r.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(r.metadata, '$.labels'), 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
    JSON_AGG(
        CASE
            WHEN v.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                'id', v.id,
                'value', v.value
            )
        END
    ) as values
FROM registered_resources r
LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
WHERE
    ($1 IS NULL OR r.id = $1) AND
    ($2 IS NULL OR r.name = $2)
GROUP BY r.id
`

type GetRegisteredResourceParams struct {
	ID   interface{} `json:"id"`
	Name interface{} `json:"name"`
}

type GetRegisteredResourceRow struct {
	ID       string          `json:"id"`
	Name     string          `json:"name"`
	Metadata json.RawMessage `json:"metadata"`
	Values   json.RawMessage `json:"values"`
}

// GetRegisteredResource
//
//	SELECT
//	    r.id,
//	    r.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(r.metadata, '$.labels'), 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
//	    JSON_AGG(
//	        CASE
//	            WHEN v.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                'id', v.id,
//	                'value', v.value
//	            )
//	        END
//	    ) as values
//	FROM registered_resources r
//	LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
//	WHERE
//	    ($1 IS NULL OR r.id = $1) AND
//	    ($2 IS NULL OR r.name = $2)
//	GROUP BY r.id
func (q *Queries) GetRegisteredResource(ctx context.Context, arg GetRegisteredResourceParams) (GetRegisteredResourceRow, error) {
	row := q.db.QueryRowContext(ctx, getRegisteredResource, arg.ID, arg.Name)
	var i GetRegisteredResourceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Metadata,
		&i.Values,
	)
	return i, err
}

const getRegisteredResourceValue = `-- name: GetRegisteredResourceValue :one
SELECT
    v.id,
    v.registered_resource_id,
    v.value,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(v.metadata, '$.labels'), 'created_at', v.created_at, 'updated_at', v.updated_at)) as metadata,
    JSON_AGG(
        CASE
            WHEN rav.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                'action', JSON_BUILD_OBJECT(
                    'id', a.id,
                    'name', a.name
                ),
                'attribute_value', JSON_BUILD_OBJECT(
                    'id', av.id,
                    'value', av.value,
                    'fqn', fqns.fqn
                )
            )
        END
    ) as action_attribute_values
FROM registered_resource_values v
JOIN registered_resources r ON v.registered_resource_id = r.id
LEFT JOIN registered_resource_action_attribute_values rav ON v.id = rav.registered_resource_value_id
LEFT JOIN actions a on rav.action_id = a.id
LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
WHERE
    ($1 IS NULL OR v.id = $1) AND
    ($2 IS NULL OR r.name = $2) AND
    ($3 IS NULL OR v.value = $3)
GROUP BY v.id
`

type GetRegisteredResourceValueParams struct {
	ID    interface{} `json:"id"`
	Name  interface{} `json:"name"`
	Value interface{} `json:"value"`
}

type GetRegisteredResourceValueRow struct {
	ID                    string          `json:"id"`
	RegisteredResourceID  sql.NullString  `json:"registered_resource_id"`
	Value                 string          `json:"value"`
	Metadata              json.RawMessage `json:"metadata"`
	ActionAttributeValues json.RawMessage `json:"action_attribute_values"`
}

// GetRegisteredResourceValue
//
//	SELECT
//	    v.id,
//	    v.registered_resource_id,
//	    v.value,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(v.metadata, '$.labels'), 'created_at', v.created_at, 'updated_at', v.updated_at)) as metadata,
//	    JSON_AGG(
//	        CASE
//	            WHEN rav.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                'action', JSON_BUILD_OBJECT(
//	                    'id', a.id,
//	                    'name', a.name
//	                ),
//	                'attribute_value', JSON_BUILD_OBJECT(
//	                    'id', av.id,
//	                    'value', av.value,
//	                    'fqn', fqns.fqn
//	                )
//	            )
//	        END
//	    ) as action_attribute_values
//	FROM registered_resource_values v
//	JOIN registered_resources r ON v.registered_resource_id = r.id
//	LEFT JOIN registered_resource_action_attribute_values rav ON v.id = rav.registered_resource_value_id
//	LEFT JOIN actions a on rav.action_id = a.id
//	LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	WHERE
//	    ($1 IS NULL OR v.id = $1) AND
//	    ($2 IS NULL OR r.name = $2) AND
//	    ($3 IS NULL OR v.value = $3)
//	GROUP BY v.id
func (q *Queries) GetRegisteredResourceValue(ctx context.Context, arg GetRegisteredResourceValueParams) (GetRegisteredResourceValueRow, error) {
	row := q.db.QueryRowContext(ctx, getRegisteredResourceValue, arg.ID, arg.Name, arg.Value)
	var i GetRegisteredResourceValueRow
	err := row.Scan(
		&i.ID,
		&i.RegisteredResourceID,
		&i.Value,
		&i.Metadata,
		&i.ActionAttributeValues,
	)
	return i, err
}

const listRegisteredResourceValues = `-- name: ListRegisteredResourceValues :many
WITH counted AS (
    SELECT COUNT(v.id) AS total
    FROM registered_resource_values v
    WHERE $1 IS NULL OR v.registered_resource_id = $1
)
SELECT
    v.id,
    v.registered_resource_id,
    v.value,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(v.metadata, '$.labels'), 'created_at', v.created_at, 'updated_at', v.updated_at)) as metadata,
    JSON_AGG(
        CASE
            WHEN rav.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                'action', JSON_BUILD_OBJECT(
                    'id', a.id,
                    'name', a.name
                ),
                'attribute_value', JSON_BUILD_OBJECT(
                    'id', av.id,
                    'value', av.value,
                    'fqn', fqns.fqn
                )
            )
        END
    ) as action_attribute_values,
    counted.total
FROM registered_resource_values v
JOIN registered_resources r ON v.registered_resource_id = r.id
LEFT JOIN registered_resource_action_attribute_values rav ON v.id = rav.registered_resource_value_id
LEFT JOIN actions a on rav.action_id = a.id
LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id  
CROSS JOIN counted
WHERE
    $1 IS NULL OR v.registered_resource_id = $1
GROUP BY v.id, counted.total
ORDER BY v.created_at DESC
LIMIT $3
OFFSET $2
`

type ListRegisteredResourceValuesParams struct {
	RegisteredResourceID interface{} `json:"registered_resource_id"`
	Offset               int32       `json:"offset_"`
	Limit                int32       `json:"limit_"`
}

type ListRegisteredResourceValuesRow struct {
	ID                    string          `json:"id"`
	RegisteredResourceID  sql.NullString  `json:"registered_resource_id"`
	Value                 string          `json:"value"`
	Metadata              json.RawMessage `json:"metadata"`
	ActionAttributeValues json.RawMessage `json:"action_attribute_values"`
	Total                 int64           `json:"total"`
}

// ListRegisteredResourceValues
//
//	WITH counted AS (
//	    SELECT COUNT(v.id) AS total
//	    FROM registered_resource_values v
//	    WHERE $1 IS NULL OR v.registered_resource_id = $1
//	)
//	SELECT
//	    v.id,
//	    v.registered_resource_id,
//	    v.value,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(v.metadata, '$.labels'), 'created_at', v.created_at, 'updated_at', v.updated_at)) as metadata,
//	    JSON_AGG(
//	        CASE
//	            WHEN rav.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                'action', JSON_BUILD_OBJECT(
//	                    'id', a.id,
//	                    'name', a.name
//	                ),
//	                'attribute_value', JSON_BUILD_OBJECT(
//	                    'id', av.id,
//	                    'value', av.value,
//	                    'fqn', fqns.fqn
//	                )
//	            )
//	        END
//	    ) as action_attribute_values,
//	    counted.total
//	FROM registered_resource_values v
//	JOIN registered_resources r ON v.registered_resource_id = r.id
//	LEFT JOIN registered_resource_action_attribute_values rav ON v.id = rav.registered_resource_value_id
//	LEFT JOIN actions a on rav.action_id = a.id
//	LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	CROSS JOIN counted
//	WHERE
//	    $1 IS NULL OR v.registered_resource_id = $1
//	GROUP BY v.id, counted.total
//	ORDER BY v.created_at DESC
//	LIMIT $3
//	OFFSET $2
func (q *Queries) ListRegisteredResourceValues(ctx context.Context, arg ListRegisteredResourceValuesParams) ([]ListRegisteredResourceValuesRow, error) {
	rows, err := q.db.QueryContext(ctx, listRegisteredResourceValues, arg.RegisteredResourceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRegisteredResourceValuesRow
	for rows.Next() {
		var i ListRegisteredResourceValuesRow
		if err := rows.Scan(
			&i.ID,
			&i.RegisteredResourceID,
			&i.Value,
			&i.Metadata,
			&i.ActionAttributeValues,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegisteredResources = `-- name: ListRegisteredResources :many
WITH counted AS (
    SELECT COUNT(id) AS total
    FROM registered_resources
)
SELECT
    r.id,
    r.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(r.metadata, '$.labels'), 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
    -- Aggregate all values for this resource into a JSON array, filtering NULL entries
    JSON_AGG(
        CASE
            WHEN v.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                'id', v.id,
                'value', v.value,
                'action_attribute_values', action_attrs.values
            )
        END
    ) as values,
    counted.total
FROM registered_resources r
CROSS JOIN counted
LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
LEFT JOIN (
    SELECT
        rav.registered_resource_value_id,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'action', JSON_BUILD_OBJECT(
                    'id', a.id,
                    'name', a.name
                ),
                'attribute_value', JSON_BUILD_OBJECT(
                    'id', av.id,
                    'value', av.value,
                    'fqn', fqns.fqn
                )
            )
        ) AS values
    FROM registered_resource_action_attribute_values rav
    LEFT JOIN actions a on rav.action_id = a.id
    LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
    LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
    GROUP BY rav.registered_resource_value_id
) action_attrs ON action_attrs.registered_resource_value_id = v.id
GROUP BY r.id, counted.total
ORDER BY r.created_at DESC
LIMIT $2 
OFFSET $1
`

type ListRegisteredResourcesParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type ListRegisteredResourcesRow struct {
	ID       string          `json:"id"`
	Name     string          `json:"name"`
	Metadata json.RawMessage `json:"metadata"`
	Values   json.RawMessage `json:"values"`
	Total    int64           `json:"total"`
}

// ListRegisteredResources
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total
//	    FROM registered_resources
//	)
//	SELECT
//	    r.id,
//	    r.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(r.metadata, '$.labels'), 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
//	    -- Aggregate all values for this resource into a JSON array, filtering NULL entries
//	    JSON_AGG(
//	        CASE
//	            WHEN v.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                'id', v.id,
//	                'value', v.value,
//	                'action_attribute_values', action_attrs.values
//	            )
//	        END
//	    ) as values,
//	    counted.total
//	FROM registered_resources r
//	CROSS JOIN counted
//	LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
//	LEFT JOIN (
//	    SELECT
//	        rav.registered_resource_value_id,
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'action', JSON_BUILD_OBJECT(
//	                    'id', a.id,
//	                    'name', a.name
//	                ),
//	                'attribute_value', JSON_BUILD_OBJECT(
//	                    'id', av.id,
//	                    'value', av.value,
//	                    'fqn', fqns.fqn
//	                )
//	            )
//	        ) AS values
//	    FROM registered_resource_action_attribute_values rav
//	    LEFT JOIN actions a on rav.action_id = a.id
//	    LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
//	    LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	    GROUP BY rav.registered_resource_value_id
//	) action_attrs ON action_attrs.registered_resource_value_id = v.id
//	GROUP BY r.id, counted.total
//	ORDER BY r.created_at DESC
//	LIMIT $2
//	OFFSET $1
func (q *Queries) ListRegisteredResources(ctx context.Context, arg ListRegisteredResourcesParams) ([]ListRegisteredResourcesRow, error) {
	rows, err := q.db.QueryContext(ctx, listRegisteredResources, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRegisteredResourcesRow
	for rows.Next() {
		var i ListRegisteredResourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Metadata,
			&i.Values,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRegisteredResource = `-- name: UpdateRegisteredResource :execrows
UPDATE registered_resources
SET
    name = COALESCE($2, name),
    metadata = COALESCE($3, metadata),
    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now', '+0.001 seconds')
WHERE id = $1
`

type UpdateRegisteredResourceParams struct {
	ID       string         `json:"id"`
	Name     sql.NullString `json:"name"`
	Metadata sql.NullString `json:"metadata"`
}

// UpdateRegisteredResource
//
//	UPDATE registered_resources
//	SET
//	    name = COALESCE($2, name),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) UpdateRegisteredResource(ctx context.Context, arg UpdateRegisteredResourceParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateRegisteredResource, arg.ID, arg.Name, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateRegisteredResourceValue = `-- name: UpdateRegisteredResourceValue :execrows
UPDATE registered_resource_values
SET
    value = COALESCE($2, value),
    metadata = COALESCE($3, metadata),
    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now', '+0.001 seconds')
WHERE id = $1
`

type UpdateRegisteredResourceValueParams struct {
	ID       string         `json:"id"`
	Value    sql.NullString `json:"value"`
	Metadata sql.NullString `json:"metadata"`
}

// UpdateRegisteredResourceValue
//
//	UPDATE registered_resource_values
//	SET
//	    value = COALESCE($2, value),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) UpdateRegisteredResourceValue(ctx context.Context, arg UpdateRegisteredResourceValueParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateRegisteredResourceValue, arg.ID, arg.Value, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
