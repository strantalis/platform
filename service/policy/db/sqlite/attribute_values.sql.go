// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attribute_values.sql

package dbsqlite

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/sqlc-dev/pqtype"
)

const assignPublicKeyToAttributeValue = `-- name: AssignPublicKeyToAttributeValue :one
INSERT INTO attribute_value_public_key_map (value_id, key_access_server_key_id)
VALUES ($1, $2)
RETURNING value_id, key_access_server_key_id
`

type AssignPublicKeyToAttributeValueParams struct {
	ValueID              sql.NullString `json:"value_id"`
	KeyAccessServerKeyID sql.NullString `json:"key_access_server_key_id"`
}

// AssignPublicKeyToAttributeValue
//
//	INSERT INTO attribute_value_public_key_map (value_id, key_access_server_key_id)
//	VALUES ($1, $2)
//	RETURNING value_id, key_access_server_key_id
func (q *Queries) AssignPublicKeyToAttributeValue(ctx context.Context, arg AssignPublicKeyToAttributeValueParams) (AttributeValuePublicKeyMap, error) {
	row := q.db.QueryRowContext(ctx, assignPublicKeyToAttributeValue, arg.ValueID, arg.KeyAccessServerKeyID)
	var i AttributeValuePublicKeyMap
	err := row.Scan(&i.ValueID, &i.KeyAccessServerKeyID)
	return i, err
}

const createAttributeValue = `-- name: CreateAttributeValue :one
INSERT INTO attribute_values (id, attribute_definition_id, value, metadata, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, $3, STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'), STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')) 
RETURNING id
`

type CreateAttributeValueParams struct {
	AttributeDefinitionID sql.NullString `json:"attribute_definition_id"`
	Value                 string         `json:"value"`
	Metadata              sql.NullString `json:"metadata"`
}

// CreateAttributeValue
//
//	INSERT INTO attribute_values (id, attribute_definition_id, value, metadata, created_at, updated_at)
//	VALUES (gen_random_uuid(), $1, $2, $3, STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'), STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'))
//	RETURNING id
func (q *Queries) CreateAttributeValue(ctx context.Context, arg CreateAttributeValueParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createAttributeValue, arg.AttributeDefinitionID, arg.Value, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAttributeValue = `-- name: DeleteAttributeValue :execrows
DELETE FROM attribute_values WHERE id = $1
`

// DeleteAttributeValue
//
//	DELETE FROM attribute_values WHERE id = $1
func (q *Queries) DeleteAttributeValue(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAttributeValue, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAttributeValue = `-- name: GetAttributeValue :one
WITH obligation_triggers_agg AS (
    SELECT
        ot.obligation_value_id,
        JSON_AGG(
            DISTINCT JSON_BUILD_OBJECT(
                'id', ot.id,
                'action', JSON_BUILD_OBJECT(
                    'id', a.id,
                    'name', a.name
                ),
                'attribute_value', JSON_BUILD_OBJECT(
                    'id', av.id,
                    'fqn', av_fqns.fqn
                ),
                'context', CASE
                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
                        JSON_BUILD_OBJECT(
                            'pep', JSON_BUILD_OBJECT(
                                'client_id', ot.client_id
                            )
                        )
                    )
                    ELSE '[]'
                END
            )
        ) AS triggers
    FROM obligation_triggers ot
    JOIN actions a ON ot.action_id = a.id
    JOIN attribute_values av ON ot.attribute_value_id = av.id
    LEFT JOIN attribute_fqns av_fqns ON av.id = av_fqns.value_id
    GROUP BY ot.obligation_value_id
),
obligation_values_agg AS (
    SELECT
        ov.obligation_definition_id,
        JSON_AGG(
            DISTINCT JSON_BUILD_OBJECT(
                'id', ov.id,
                'value', ov.value,
                'fqn', ns_fqns.fqn || '/obl/' || od.name || '/value/' || ov.value,
                'triggers', COALESCE(ota.triggers, '[]')
            )
        ) AS "values"
    FROM obligation_values_standard ov
    LEFT JOIN obligation_triggers_agg ota ON ov.id = ota.obligation_value_id
    JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
    JOIN attribute_namespaces n ON od.namespace_id = n.id
    LEFT JOIN attribute_fqns ns_fqns ON n.id = ns_fqns.namespace_id AND ns_fqns.attribute_id IS NULL AND ns_fqns.value_id IS NULL
    GROUP BY ov.obligation_definition_id
),
attribute_obligations AS (
    SELECT
        ot.attribute_value_id,
        JSON_AGG(
            DISTINCT JSON_BUILD_OBJECT(
                'id', od.id,
                'name', od.name,
                'fqn', ns_fqns.fqn || '/obl/' || od.name,
                'namespace', JSON_BUILD_OBJECT(
                    'id', n.id,
                    'name', n.name,
                    'fqn', ns_fqns.fqn
                ),
                'values', COALESCE(ova."values", '[]')
            )
        ) AS obligations
    FROM obligation_triggers ot
    JOIN obligation_values_standard ov ON ot.obligation_value_id = ov.id
    JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
    JOIN attribute_namespaces n ON od.namespace_id = n.id
    LEFT JOIN attribute_fqns ns_fqns ON n.id = ns_fqns.namespace_id AND ns_fqns.attribute_id IS NULL AND ns_fqns.value_id IS NULL
    LEFT JOIN obligation_values_agg ova ON od.id = ova.obligation_definition_id
    GROUP BY ot.attribute_value_id
)
SELECT
    av.id,
    av.value,
    av.active,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(av.metadata, '$.labels'), 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
    av.attribute_definition_id,
    fqns.fqn,
    COALESCE(JSON_AGG(
        DISTINCT CASE
            WHEN avkag.attribute_value_id IS NOT NULL THEN JSON_BUILD_OBJECT(
                'id', kas.id,
                'uri', kas.uri,
                'name', kas.name,
                'public_key', kas.public_key
            )
        END
    ), JSON_BUILD_ARRAY()) AS grants,
    COALESCE(value_keys.keys, JSON_BUILD_ARRAY()) as keys,
    ao.obligations
FROM attribute_values av
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
LEFT JOIN attribute_value_key_access_grants avkag ON av.id = avkag.attribute_value_id
LEFT JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
LEFT JOIN (
    SELECT
        k.value_id,
        JSON_AGG(
            DISTINCT CASE
                WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'kas_uri', kas.uri,
                    'kas_id', kas.id,
                    'public_key', JSON_BUILD_OBJECT(
                         'algorithm', kask.key_algorithm,
                         'kid', kask.key_id,
                         'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
                    )
                )
            END
        ) AS keys
    FROM attribute_value_public_key_map k
    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
    INNER JOIN key_access_servers kas ON kas.id = kask.key_access_server_id
    GROUP BY k.value_id
) value_keys ON av.id = value_keys.value_id
LEFT JOIN attribute_obligations ao ON av.id = ao.attribute_value_id
WHERE ($1 IS NULL OR av.id = $1)
  AND ($2 IS NULL OR REGEXP_REPLACE(fqns.fqn, '^https://', '') = REGEXP_REPLACE($2, '^https://', ''))
GROUP BY av.id, fqns.fqn, value_keys.keys, ao.obligations
`

type GetAttributeValueParams struct {
	ID  interface{} `json:"id"`
	Fqn interface{} `json:"fqn"`
}

type GetAttributeValueRow struct {
	ID                    string                `json:"id"`
	Value                 string                `json:"value"`
	Active                sql.NullBool          `json:"active"`
	Metadata              json.RawMessage       `json:"metadata"`
	AttributeDefinitionID sql.NullString        `json:"attribute_definition_id"`
	Fqn                   sql.NullString        `json:"fqn"`
	Grants                json.RawMessage       `json:"grants"`
	Keys                  json.RawMessage       `json:"keys"`
	Obligations           pqtype.NullRawMessage `json:"obligations"`
}

// GetAttributeValue
//
//	WITH obligation_triggers_agg AS (
//	    SELECT
//	        ot.obligation_value_id,
//	        JSON_AGG(
//	            DISTINCT JSON_BUILD_OBJECT(
//	                'id', ot.id,
//	                'action', JSON_BUILD_OBJECT(
//	                    'id', a.id,
//	                    'name', a.name
//	                ),
//	                'attribute_value', JSON_BUILD_OBJECT(
//	                    'id', av.id,
//	                    'fqn', av_fqns.fqn
//	                ),
//	                'context', CASE
//	                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
//	                        JSON_BUILD_OBJECT(
//	                            'pep', JSON_BUILD_OBJECT(
//	                                'client_id', ot.client_id
//	                            )
//	                        )
//	                    )
//	                    ELSE '[]'
//	                END
//	            )
//	        ) AS triggers
//	    FROM obligation_triggers ot
//	    JOIN actions a ON ot.action_id = a.id
//	    JOIN attribute_values av ON ot.attribute_value_id = av.id
//	    LEFT JOIN attribute_fqns av_fqns ON av.id = av_fqns.value_id
//	    GROUP BY ot.obligation_value_id
//	),
//	obligation_values_agg AS (
//	    SELECT
//	        ov.obligation_definition_id,
//	        JSON_AGG(
//	            DISTINCT JSON_BUILD_OBJECT(
//	                'id', ov.id,
//	                'value', ov.value,
//	                'fqn', ns_fqns.fqn || '/obl/' || od.name || '/value/' || ov.value,
//	                'triggers', COALESCE(ota.triggers, '[]')
//	            )
//	        ) AS values
//	    FROM obligation_values_standard ov
//	    LEFT JOIN obligation_triggers_agg ota ON ov.id = ota.obligation_value_id
//	    JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
//	    JOIN attribute_namespaces n ON od.namespace_id = n.id
//	    LEFT JOIN attribute_fqns ns_fqns ON n.id = ns_fqns.namespace_id AND ns_fqns.attribute_id IS NULL AND ns_fqns.value_id IS NULL
//	    GROUP BY ov.obligation_definition_id
//	),
//	attribute_obligations AS (
//	    SELECT
//	        ot.attribute_value_id,
//	        JSON_AGG(
//	            DISTINCT JSON_BUILD_OBJECT(
//	                'id', od.id,
//	                'name', od.name,
//	                'fqn', ns_fqns.fqn || '/obl/' || od.name,
//	                'namespace', JSON_BUILD_OBJECT(
//	                    'id', n.id,
//	                    'name', n.name,
//	                    'fqn', ns_fqns.fqn
//	                ),
//	                'values', COALESCE(ova.values, '[]')
//	            )
//	        ) AS obligations
//	    FROM obligation_triggers ot
//	    JOIN obligation_values_standard ov ON ot.obligation_value_id = ov.id
//	    JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
//	    JOIN attribute_namespaces n ON od.namespace_id = n.id
//	    LEFT JOIN attribute_fqns ns_fqns ON n.id = ns_fqns.namespace_id AND ns_fqns.attribute_id IS NULL AND ns_fqns.value_id IS NULL
//	    LEFT JOIN obligation_values_agg ova ON od.id = ova.obligation_definition_id
//	    GROUP BY ot.attribute_value_id
//	)
//	SELECT
//	    av.id,
//	    av.value,
//	    av.active,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(av.metadata, '$.labels'), 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
//	    av.attribute_definition_id,
//	    fqns.fqn,
//	    JSON_AGG(
//	        DISTINCT CASE
//	            WHEN avkag.attribute_value_id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                'id', kas.id,
//	                'uri', kas.uri,
//	                'name', kas.name,
//	                'public_key', kas.public_key
//	            )
//	        END
//	    ) AS grants,
//	    value_keys.keys as keys,
//	    ao.obligations
//	FROM attribute_values av
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	LEFT JOIN attribute_value_key_access_grants avkag ON av.id = avkag.attribute_value_id
//	LEFT JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
//	LEFT JOIN (
//	    SELECT
//	        k.value_id,
//	        JSON_AGG(
//	            DISTINCT CASE
//	                WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'kas_uri', kas.uri,
//	                    'kas_id', kas.id,
//	                    'public_key', JSON_BUILD_OBJECT(
//	                         'algorithm', kask.key_algorithm,
//	                         'kid', kask.key_id,
//	                         'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
//	                    )
//	                )
//	            END
//	        ) AS keys
//	    FROM attribute_value_public_key_map k
//	    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	    INNER JOIN key_access_servers kas ON kas.id = kask.key_access_server_id
//	    GROUP BY k.value_id
//	) value_keys ON av.id = value_keys.value_id
//	LEFT JOIN attribute_obligations ao ON av.id = ao.attribute_value_id
//	WHERE ($1 IS NULL OR av.id = $1)
//	  AND ($2 IS NULL OR REGEXP_REPLACE(fqns.fqn, '^https://', '') = REGEXP_REPLACE($2, '^https://', ''))
//	GROUP BY av.id, fqns.fqn, value_keys.keys, ao.obligations
func (q *Queries) GetAttributeValue(ctx context.Context, arg GetAttributeValueParams) (GetAttributeValueRow, error) {
	row := q.db.QueryRowContext(ctx, getAttributeValue, arg.ID, arg.Fqn)
	var i GetAttributeValueRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Active,
		&i.Metadata,
		&i.AttributeDefinitionID,
		&i.Fqn,
		&i.Grants,
		&i.Keys,
		&i.Obligations,
	)
	return i, err
}

const listAttributeValues = `-- name: ListAttributeValues :many

SELECT
    COUNT(*) OVER() AS total,
    av.id,
    av.value,
    av.active,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(av.metadata, '$.labels'), 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
    av.attribute_definition_id,
    fqns.fqn
FROM attribute_values av
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
WHERE (
    ($1 IS NULL OR av.active = $1) AND
    ($2 IS NULL OR av.attribute_definition_id = $2) 
)
ORDER BY av.created_at DESC
LIMIT $4 
OFFSET $3
`

type ListAttributeValuesParams struct {
	Active                interface{} `json:"active"`
	AttributeDefinitionID interface{} `json:"attribute_definition_id"`
	Offset                int32       `json:"offset_"`
	Limit                 int32       `json:"limit_"`
}

type ListAttributeValuesRow struct {
	Total                 int64           `json:"total"`
	ID                    string          `json:"id"`
	Value                 string          `json:"value"`
	Active                sql.NullBool    `json:"active"`
	Metadata              json.RawMessage `json:"metadata"`
	AttributeDefinitionID sql.NullString  `json:"attribute_definition_id"`
	Fqn                   sql.NullString  `json:"fqn"`
}

// --------------------------------------------------------------
// ATTRIBUTE VALUES
// --------------------------------------------------------------
//
//	SELECT
//	    COUNT(*) OVER() AS total,
//	    av.id,
//	    av.value,
//	    av.active,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(av.metadata, '$.labels'), 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
//	    av.attribute_definition_id,
//	    fqns.fqn
//	FROM attribute_values av
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	WHERE (
//	    ($1 IS NULL OR av.active = $1) AND
//	    ($2 IS NULL OR av.attribute_definition_id = $2)
//	)
//	ORDER BY av.created_at DESC
//	LIMIT $4
//	OFFSET $3
func (q *Queries) ListAttributeValues(ctx context.Context, arg ListAttributeValuesParams) ([]ListAttributeValuesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttributeValues,
		arg.Active,
		arg.AttributeDefinitionID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttributeValuesRow
	for rows.Next() {
		var i ListAttributeValuesRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.Value,
			&i.Active,
			&i.Metadata,
			&i.AttributeDefinitionID,
			&i.Fqn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeKeyAccessServerFromAttributeValue = `-- name: RemoveKeyAccessServerFromAttributeValue :execrows
DELETE FROM attribute_value_key_access_grants
WHERE attribute_value_id = $1 AND key_access_server_id = $2
`

type RemoveKeyAccessServerFromAttributeValueParams struct {
	AttributeValueID  sql.NullString `json:"attribute_value_id"`
	KeyAccessServerID sql.NullString `json:"key_access_server_id"`
}

// RemoveKeyAccessServerFromAttributeValue
//
//	DELETE FROM attribute_value_key_access_grants
//	WHERE attribute_value_id = $1 AND key_access_server_id = $2
func (q *Queries) RemoveKeyAccessServerFromAttributeValue(ctx context.Context, arg RemoveKeyAccessServerFromAttributeValueParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeKeyAccessServerFromAttributeValue, arg.AttributeValueID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const removePublicKeyFromAttributeValue = `-- name: RemovePublicKeyFromAttributeValue :execrows
DELETE FROM attribute_value_public_key_map
WHERE value_id = $1 AND key_access_server_key_id = $2
`

type RemovePublicKeyFromAttributeValueParams struct {
	ValueID              sql.NullString `json:"value_id"`
	KeyAccessServerKeyID sql.NullString `json:"key_access_server_key_id"`
}

// RemovePublicKeyFromAttributeValue
//
//	DELETE FROM attribute_value_public_key_map
//	WHERE value_id = $1 AND key_access_server_key_id = $2
func (q *Queries) RemovePublicKeyFromAttributeValue(ctx context.Context, arg RemovePublicKeyFromAttributeValueParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removePublicKeyFromAttributeValue, arg.ValueID, arg.KeyAccessServerKeyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const rotatePublicKeyForAttributeValue = `-- name: RotatePublicKeyForAttributeValue :many
UPDATE attribute_value_public_key_map
SET key_access_server_key_id = $1
WHERE (key_access_server_key_id = $2)
RETURNING value_id
`

type RotatePublicKeyForAttributeValueParams struct {
	NewKeyID sql.NullString `json:"new_key_id"`
	OldKeyID sql.NullString `json:"old_key_id"`
}

// RotatePublicKeyForAttributeValue
//
//	UPDATE attribute_value_public_key_map
//	SET key_access_server_key_id = $1
//	WHERE (key_access_server_key_id = $2)
//	RETURNING value_id
func (q *Queries) RotatePublicKeyForAttributeValue(ctx context.Context, arg RotatePublicKeyForAttributeValueParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, rotatePublicKeyForAttributeValue, arg.NewKeyID, arg.OldKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var value_id sql.NullString
		if err := rows.Scan(&value_id); err != nil {
			return nil, err
		}
		items = append(items, value_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAttributeValue = `-- name: UpdateAttributeValue :execrows
UPDATE attribute_values
SET
    value = COALESCE($2, value),
    active = COALESCE($3, active),
    metadata = COALESCE($4, metadata),
    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = $1
`

type UpdateAttributeValueParams struct {
	ID       string         `json:"id"`
	Value    sql.NullString `json:"value"`
	Active   sql.NullBool   `json:"active"`
	Metadata sql.NullString `json:"metadata"`
}

// updateAttributeValue: Safe and Unsafe Updates both
//
//	UPDATE attribute_values
//	SET
//	    value = COALESCE($2, value),
//	    active = COALESCE($3, active),
//	    metadata = COALESCE($4, metadata),
//	    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
//	WHERE id = $1
func (q *Queries) UpdateAttributeValue(ctx context.Context, arg UpdateAttributeValueParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAttributeValue,
		arg.ID,
		arg.Value,
		arg.Active,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
