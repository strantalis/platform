// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subject_mappings.sql

package dbsqlite

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createSubjectConditionSet = `-- name: CreateSubjectConditionSet :one
INSERT INTO subject_condition_set (id, condition, metadata, created_at, updated_at)
VALUES (
    gen_random_uuid(),
    $1,
    $2,
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'),
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
)
RETURNING id
`

type CreateSubjectConditionSetParams struct {
	Condition sql.NullString `json:"condition"`
	Metadata  sql.NullString `json:"metadata"`
}

// CreateSubjectConditionSet
//
//	INSERT INTO subject_condition_set (condition, metadata)
//	VALUES ($1, $2)
//	RETURNING id
func (q *Queries) CreateSubjectConditionSet(ctx context.Context, arg CreateSubjectConditionSetParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createSubjectConditionSet, arg.Condition, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createSubjectMapping = `-- name: CreateSubjectMapping :one
WITH inserted_mapping AS (
    INSERT INTO subject_mappings (
        id,
        attribute_value_id,
        metadata,
        subject_condition_set_id,
        created_at,
        updated_at
    )
    VALUES (
        gen_random_uuid(),
        $1,
        $2,
        $3,
        STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'),
        STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
    )
    RETURNING id
),
inserted_actions AS (
    INSERT INTO subject_mapping_actions (subject_mapping_id, action_id)
    SELECT 
        (SELECT id FROM inserted_mapping),
        action_ids.value
    FROM json_each($4) AS action_ids(value)
    RETURNING action_id
)
SELECT id FROM inserted_mapping
`

type CreateSubjectMappingParams struct {
	AttributeValueID      sql.NullString  `json:"attribute_value_id"`
	Metadata              sql.NullString  `json:"metadata"`
	SubjectConditionSetID sql.NullString  `json:"subject_condition_set_id"`
	ActionIds             json.RawMessage `json:"action_ids"`
}

// CreateSubjectMapping
//
//	WITH inserted_mapping AS (
//	    INSERT INTO subject_mappings (
//	        attribute_value_id,
//	        metadata,
//	        subject_condition_set_id
//	    )
//	    VALUES ($1, $2, $3)
//	    RETURNING id
//	),
//	inserted_actions AS (
//	    INSERT INTO subject_mapping_actions (subject_mapping_id, action_id)
//	    SELECT
//	        (SELECT id FROM inserted_mapping),
//	        action_ids.value
//	    FROM json_each($4) AS action_ids(value)
//	)
//	SELECT id FROM inserted_mapping
func (q *Queries) CreateSubjectMapping(ctx context.Context, arg CreateSubjectMappingParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createSubjectMapping,
		arg.AttributeValueID,
		arg.Metadata,
		arg.SubjectConditionSetID,
		arg.ActionIds,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAllUnmappedSubjectConditionSets = `-- name: DeleteAllUnmappedSubjectConditionSets :many
DELETE FROM subject_condition_set
WHERE id NOT IN (SELECT DISTINCT sm.subject_condition_set_id FROM subject_mappings sm)
RETURNING id
`

// DeleteAllUnmappedSubjectConditionSets
//
//	DELETE FROM subject_condition_set
//	WHERE id NOT IN (SELECT DISTINCT sm.subject_condition_set_id FROM subject_mappings sm)
//	RETURNING id
func (q *Queries) DeleteAllUnmappedSubjectConditionSets(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, deleteAllUnmappedSubjectConditionSets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteSubjectConditionSet = `-- name: DeleteSubjectConditionSet :execrows
DELETE FROM subject_condition_set WHERE id = $1
`

// DeleteSubjectConditionSet
//
//	DELETE FROM subject_condition_set WHERE id = $1
func (q *Queries) DeleteSubjectConditionSet(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSubjectConditionSet, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteSubjectMapping = `-- name: DeleteSubjectMapping :execrows
DELETE FROM subject_mappings WHERE id = $1
`

// DeleteSubjectMapping
//
//	DELETE FROM subject_mappings WHERE id = $1
func (q *Queries) DeleteSubjectMapping(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSubjectMapping, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getSubjectConditionSet = `-- name: GetSubjectConditionSet :one
SELECT
    id,
    condition,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(metadata, '$.labels'), 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM subject_condition_set
WHERE id = $1
`

type GetSubjectConditionSetRow struct {
	ID        string          `json:"id"`
	Condition sql.NullString  `json:"condition"`
	Metadata  json.RawMessage `json:"metadata"`
}

// GetSubjectConditionSet
//
//	SELECT
//	    id,
//	    condition,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(metadata, '$.labels'), 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM subject_condition_set
//	WHERE id = $1
func (q *Queries) GetSubjectConditionSet(ctx context.Context, id string) (GetSubjectConditionSetRow, error) {
	row := q.db.QueryRowContext(ctx, getSubjectConditionSet, id)
	var i GetSubjectConditionSetRow
	err := row.Scan(&i.ID, &i.Condition, &i.Metadata)
	return i, err
}

const getSubjectMapping = `-- name: GetSubjectMapping :one
SELECT
    sm.id,
    (
        SELECT JSON_AGG(JSON_BUILD_OBJECT('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = TRUE
    ) AS standard_actions,
    (
        SELECT JSON_AGG(JSON_BUILD_OBJECT('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = FALSE
    ) AS custom_actions,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(sm.metadata, '$.labels'), 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
    JSON_BUILD_OBJECT(
        'id', scs.id,
        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(scs.metadata, '$.labels'), 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
        'subject_sets', scs.condition
    ) AS subject_condition_set,
    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
FROM subject_mappings sm
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
WHERE sm.id = $1
GROUP BY av.id, sm.id, scs.id
`

type GetSubjectMappingRow struct {
	ID                  string          `json:"id"`
	StandardActions     json.RawMessage `json:"standard_actions"`
	CustomActions       json.RawMessage `json:"custom_actions"`
	Metadata            json.RawMessage `json:"metadata"`
	SubjectConditionSet json.RawMessage `json:"subject_condition_set"`
	AttributeValue      json.RawMessage `json:"attribute_value"`
}

// GetSubjectMapping
//
//	SELECT
//	    sm.id,
//	    (
//	        SELECT JSON_AGG(JSON_BUILD_OBJECT('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = TRUE
//	    ) AS standard_actions,
//	    (
//	        SELECT JSON_AGG(JSON_BUILD_OBJECT('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = FALSE
//	    ) AS custom_actions,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(sm.metadata, '$.labels'), 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', scs.id,
//	        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(scs.metadata, '$.labels'), 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
//	        'subject_sets', scs.condition
//	    ) AS subject_condition_set,
//	    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
//	FROM subject_mappings sm
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	WHERE sm.id = $1
//	GROUP BY av.id, sm.id, scs.id
func (q *Queries) GetSubjectMapping(ctx context.Context, id string) (GetSubjectMappingRow, error) {
	row := q.db.QueryRowContext(ctx, getSubjectMapping, id)
	var i GetSubjectMappingRow
	err := row.Scan(
		&i.ID,
		&i.StandardActions,
		&i.CustomActions,
		&i.Metadata,
		&i.SubjectConditionSet,
		&i.AttributeValue,
	)
	return i, err
}

const listSubjectConditionSets = `-- name: ListSubjectConditionSets :many

WITH counted AS (
    SELECT COUNT(scs.id) AS total
    FROM subject_condition_set scs
)
SELECT
    scs.id,
    scs.condition,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(scs.metadata, '$.labels'), 'created_at', scs.created_at, 'updated_at', scs.updated_at)) as metadata,
    counted.total
FROM subject_condition_set scs
CROSS JOIN counted
ORDER BY scs.created_at DESC
LIMIT $2 
OFFSET $1
`

type ListSubjectConditionSetsParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type ListSubjectConditionSetsRow struct {
	ID        string          `json:"id"`
	Condition sql.NullString  `json:"condition"`
	Metadata  json.RawMessage `json:"metadata"`
	Total     int64           `json:"total"`
}

// --------------------------------------------------------------
// SUBJECT CONDITION SETS
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(scs.id) AS total
//	    FROM subject_condition_set scs
//	)
//	SELECT
//	    scs.id,
//	    scs.condition,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(scs.metadata, '$.labels'), 'created_at', scs.created_at, 'updated_at', scs.updated_at)) as metadata,
//	    counted.total
//	FROM subject_condition_set scs
//	CROSS JOIN counted
//	ORDER BY scs.created_at DESC
//	LIMIT $2
//	OFFSET $1
func (q *Queries) ListSubjectConditionSets(ctx context.Context, arg ListSubjectConditionSetsParams) ([]ListSubjectConditionSetsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSubjectConditionSets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSubjectConditionSetsRow
	for rows.Next() {
		var i ListSubjectConditionSetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Condition,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubjectMappings = `-- name: ListSubjectMappings :many

WITH subject_actions AS (
    SELECT
        sma.subject_mapping_id,
        COALESCE(
            JSON_AGG(CASE WHEN a.is_standard = TRUE THEN JSON_BUILD_OBJECT('id', a.id, 'name', a.name) END),
            '[]'
        ) AS standard_actions,
        COALESCE(
            JSON_AGG(CASE WHEN a.is_standard = FALSE THEN JSON_BUILD_OBJECT('id', a.id, 'name', a.name) END),
            '[]'
        ) AS custom_actions
    FROM subject_mapping_actions sma
    JOIN actions a ON sma.action_id = a.id
    GROUP BY sma.subject_mapping_id
), counted AS (
    SELECT COUNT(sm.id) AS total
    FROM subject_mappings sm
)
SELECT
    sm.id,
    sa.standard_actions,
    sa.custom_actions,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(sm.metadata, '$.labels'), 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
    JSON_BUILD_OBJECT(
        'id', scs.id,
        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(scs.metadata, '$.labels'), 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
        'subject_sets', scs.condition
    ) AS subject_condition_set,
    JSON_BUILD_OBJECT(
        'id', av.id,
        'value', av.value,
        'active', av.active,
        'fqn', fqns.fqn
    ) AS attribute_value,
    counted.total
FROM subject_mappings sm
CROSS JOIN counted
LEFT JOIN subject_actions sa ON sm.id = sa.subject_mapping_id
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
GROUP BY
    sm.id,
    sa.standard_actions,
    sa.custom_actions,
    sm.metadata, sm.created_at, sm.updated_at, -- for metadata object
    scs.id, scs.metadata, scs.created_at, scs.updated_at, scs.condition, -- for subject_condition_set object
    av.id, av.value, av.active, -- for attribute_value object
    fqns.fqn,
    counted.total
ORDER BY sm.created_at DESC
LIMIT $2
OFFSET $1
`

type ListSubjectMappingsParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type ListSubjectMappingsRow struct {
	ID                  string          `json:"id"`
	StandardActions     interface{}     `json:"standard_actions"`
	CustomActions       interface{}     `json:"custom_actions"`
	Metadata            json.RawMessage `json:"metadata"`
	SubjectConditionSet json.RawMessage `json:"subject_condition_set"`
	AttributeValue      json.RawMessage `json:"attribute_value"`
	Total               int64           `json:"total"`
}

// --------------------------------------------------------------
// SUBJECT MAPPINGS
// --------------------------------------------------------------
//
//	WITH subject_actions AS (
//	    SELECT
//	        sma.subject_mapping_id,
//	        COALESCE(
//	            JSON_AGG(CASE WHEN a.is_standard = TRUE THEN JSON_BUILD_OBJECT('id', a.id, 'name', a.name) END),
//	            '[]'
//	        ) AS standard_actions,
//	        COALESCE(
//	            JSON_AGG(CASE WHEN a.is_standard = FALSE THEN JSON_BUILD_OBJECT('id', a.id, 'name', a.name) END),
//	            '[]'
//	        ) AS custom_actions
//	    FROM subject_mapping_actions sma
//	    JOIN actions a ON sma.action_id = a.id
//	    GROUP BY sma.subject_mapping_id
//	), counted AS (
//	    SELECT COUNT(sm.id) AS total
//	    FROM subject_mappings sm
//	)
//	SELECT
//	    sm.id,
//	    sa.standard_actions,
//	    sa.custom_actions,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(sm.metadata, '$.labels'), 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', scs.id,
//	        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(scs.metadata, '$.labels'), 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
//	        'subject_sets', scs.condition
//	    ) AS subject_condition_set,
//	    JSON_BUILD_OBJECT(
//	        'id', av.id,
//	        'value', av.value,
//	        'active', av.active,
//	        'fqn', fqns.fqn
//	    ) AS attribute_value,
//	    counted.total
//	FROM subject_mappings sm
//	CROSS JOIN counted
//	LEFT JOIN subject_actions sa ON sm.id = sa.subject_mapping_id
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	GROUP BY
//	    sm.id,
//	    sa.standard_actions,
//	    sa.custom_actions,
//	    sm.metadata, sm.created_at, sm.updated_at, -- for metadata object
//	    scs.id, scs.metadata, scs.created_at, scs.updated_at, scs.condition, -- for subject_condition_set object
//	    av.id, av.value, av.active, -- for attribute_value object
//	    fqns.fqn,
//	    counted.total
//	ORDER BY sm.created_at DESC
//	LIMIT $2
//	OFFSET $1
func (q *Queries) ListSubjectMappings(ctx context.Context, arg ListSubjectMappingsParams) ([]ListSubjectMappingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSubjectMappings, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSubjectMappingsRow
	for rows.Next() {
		var i ListSubjectMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.StandardActions,
			&i.CustomActions,
			&i.Metadata,
			&i.SubjectConditionSet,
			&i.AttributeValue,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const matchSubjectMappings = `-- name: MatchSubjectMappings :many
WITH subject_actions AS (
    SELECT
        sma.subject_mapping_id,
        COALESCE(
            JSON_AGG(CASE WHEN a.is_standard = TRUE THEN JSON_BUILD_OBJECT('id', a.id, 'name', a.name) END),
            '[]'
        ) AS standard_actions,
        COALESCE(
            JSON_AGG(CASE WHEN a.is_standard = FALSE THEN JSON_BUILD_OBJECT('id', a.id, 'name', a.name) END),
            '[]'
        ) AS custom_actions
    FROM subject_mapping_actions sma
    JOIN actions a ON sma.action_id = a.id
    GROUP BY sma.subject_mapping_id
)
SELECT
    sm.id,
    sa.standard_actions,
    sa.custom_actions,
    JSON_BUILD_OBJECT(
        'id', scs.id,
        'subject_sets', scs.condition
    ) AS subject_condition_set,
    JSON_BUILD_OBJECT(
        'id', av.id,
        'value', av.value,
        'active', av.active,
        'fqn', fqns.fqn
    ) AS attribute_value
FROM subject_mappings sm
LEFT JOIN subject_actions sa ON sm.id = sa.subject_mapping_id
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
LEFT JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
WHERE
    ns.active = TRUE
    AND ad.active = TRUE
    AND av.active = TRUE
    AND EXISTS (
        SELECT 1
        FROM json_each(COALESCE(json_extract(scs.condition, '$.subject_sets'), scs.condition)) AS ss(value)
        CROSS JOIN json_each(json_extract(ss.value, '$.condition_groups')) AS cg(value)
        CROSS JOIN json_each(json_extract(cg.value, '$.conditions')) AS cond(value)
        WHERE json_extract(cond.value, '$.subject_external_selector_value') IN (
            SELECT selectors.value FROM json_each($1) AS selectors(value)
        )
    )
GROUP BY
    sm.id,
    sa.standard_actions,
    sa.custom_actions,
    scs.id, scs.condition,
    av.id, av.value, av.active, fqns.fqn
`

type MatchSubjectMappingsRow struct {
	ID                  string          `json:"id"`
	StandardActions     interface{}     `json:"standard_actions"`
	CustomActions       interface{}     `json:"custom_actions"`
	SubjectConditionSet json.RawMessage `json:"subject_condition_set"`
	AttributeValue      json.RawMessage `json:"attribute_value"`
}

// MatchSubjectMappings
//
//	WITH subject_actions AS (
//	    SELECT
//	        sma.subject_mapping_id,
//	        COALESCE(
//	            JSON_AGG(CASE WHEN a.is_standard = TRUE THEN JSON_BUILD_OBJECT('id', a.id, 'name', a.name) END),
//	            '[]'
//	        ) AS standard_actions,
//	        COALESCE(
//	            JSON_AGG(CASE WHEN a.is_standard = FALSE THEN JSON_BUILD_OBJECT('id', a.id, 'name', a.name) END),
//	            '[]'
//	        ) AS custom_actions
//	    FROM subject_mapping_actions sma
//	    JOIN actions a ON sma.action_id = a.id
//	    GROUP BY sma.subject_mapping_id
//	)
//	SELECT
//	    sm.id,
//	    sa.standard_actions,
//	    sa.custom_actions,
//	    JSON_BUILD_OBJECT(
//	        'id', scs.id,
//	        'subject_sets', scs.condition
//	    ) AS subject_condition_set,
//	    JSON_BUILD_OBJECT(
//	        'id', av.id,
//	        'value', av.value,
//	        'active', av.active,
//	        'fqn', fqns.fqn
//	    ) AS attribute_value
//	FROM subject_mappings sm
//	LEFT JOIN subject_actions sa ON sm.id = sa.subject_mapping_id
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
//	LEFT JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	WHERE
//	    ns.active = TRUE
//	    AND ad.active = TRUE
//	    AND av.active = TRUE
//	    AND EXISTS (
//	        SELECT 1
//	        FROM json_each(COALESCE(json_extract(scs.condition, '$.subject_sets'), scs.condition)) AS ss(value)
//	        CROSS JOIN json_each(json_extract(ss.value, '$.condition_groups')) AS cg(value)
//	        CROSS JOIN json_each(json_extract(cg.value, '$.conditions')) AS cond(value)
//	        WHERE json_extract(cond.value, '$.subject_external_selector_value') IN (
//	            SELECT selectors.value FROM json_each($1) AS selectors(value)
//	        )
//	    )
//	GROUP BY
//	    sm.id,
//	    sa.standard_actions,
//	    sa.custom_actions,
//	    scs.id, scs.condition,
//	    av.id, av.value, av.active, fqns.fqn
func (q *Queries) MatchSubjectMappings(ctx context.Context, selectors json.RawMessage) ([]MatchSubjectMappingsRow, error) {
	rows, err := q.db.QueryContext(ctx, matchSubjectMappings, selectors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MatchSubjectMappingsRow
	for rows.Next() {
		var i MatchSubjectMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.StandardActions,
			&i.CustomActions,
			&i.SubjectConditionSet,
			&i.AttributeValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubjectConditionSet = `-- name: UpdateSubjectConditionSet :execrows
UPDATE subject_condition_set
SET
    condition = COALESCE($2, condition),
    metadata = COALESCE($3, metadata),
    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now', '+0.001 seconds')
WHERE id = $1
`

type UpdateSubjectConditionSetParams struct {
	ID        string         `json:"id"`
	Condition sql.NullString `json:"condition"`
	Metadata  sql.NullString `json:"metadata"`
}

// UpdateSubjectConditionSet
//
//	UPDATE subject_condition_set
//	SET
//	    condition = COALESCE($2, condition),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) UpdateSubjectConditionSet(ctx context.Context, arg UpdateSubjectConditionSetParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateSubjectConditionSet, arg.ID, arg.Condition, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateSubjectMapping = `-- name: UpdateSubjectMapping :execrows
WITH
    subject_mapping_update AS (
        UPDATE subject_mappings
        SET
            metadata = COALESCE($1, metadata),
            subject_condition_set_id = COALESCE($2, subject_condition_set_id),
            updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now', '+0.001 seconds')
        WHERE id = $3
        RETURNING id
    ),
    -- Delete any actions that are NOT in the new list
    action_delete AS (
        DELETE FROM subject_mapping_actions
        WHERE
            subject_mapping_id = $3
            AND $4 IS NOT NULL
            AND action_id NOT IN (
                SELECT action_ids.value FROM json_each($4) AS action_ids(value)
            )
        RETURNING action_id
    ),
    -- Insert actions that are not already related to the mapping
    action_insert AS (
        INSERT INTO
            subject_mapping_actions (subject_mapping_id, action_id)
        SELECT
            $3,
            a.value
        FROM json_each($4) AS a(value)
        WHERE
            $4 IS NOT NULL
            AND NOT EXISTS (
                SELECT 1
                FROM subject_mapping_actions
                WHERE subject_mapping_id = $3 AND action_id = a.value
            )
        RETURNING action_id
    ),
    update_count AS (
        SELECT COUNT(*) AS cnt
        FROM subject_mapping_update
    )
SELECT cnt
FROM update_count
`

type UpdateSubjectMappingParams struct {
	Metadata              sql.NullString `json:"metadata"`
	SubjectConditionSetID sql.NullString `json:"subject_condition_set_id"`
	ID                    string         `json:"id"`
	ActionIds             interface{}    `json:"action_ids"`
}

// UpdateSubjectMapping
//
//	WITH
//	    subject_mapping_update AS (
//	        UPDATE subject_mappings
//	        SET
//	            metadata = COALESCE($1, metadata),
//	            subject_condition_set_id = COALESCE($2, subject_condition_set_id)
//	        WHERE id = $3
//	        RETURNING id
//	    ),
//	    -- Delete any actions that are NOT in the new list
//	    action_delete AS (
//	        DELETE FROM subject_mapping_actions
//	        WHERE
//	            subject_mapping_id = $3
//	            AND $4 IS NOT NULL
//	            AND action_id NOT IN (
//	                SELECT action_ids.value FROM json_each($4) AS action_ids(value)
//	            )
//	    ),
//	    -- Insert actions that are not already related to the mapping
//	    action_insert AS (
//	        INSERT INTO
//	            subject_mapping_actions (subject_mapping_id, action_id)
//	        SELECT
//	            $3,
//	            a
//	        FROM json_each($4) AS a(value)
//	        WHERE
//	            $4 IS NOT NULL
//	            AND NOT EXISTS (
//	                SELECT 1
//	                FROM subject_mapping_actions
//	                WHERE subject_mapping_id = $3 AND action_id = a.value
//	            )
//	    ),
//	    update_count AS (
//	        SELECT COUNT(*) AS cnt
//	        FROM subject_mapping_update
//	    )
//	SELECT cnt
//	FROM update_count
func (q *Queries) UpdateSubjectMapping(ctx context.Context, arg UpdateSubjectMappingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateSubjectMapping,
		arg.Metadata,
		arg.SubjectConditionSetID,
		arg.ID,
		arg.ActionIds,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
