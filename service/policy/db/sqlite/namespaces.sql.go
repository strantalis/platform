// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: namespaces.sql

package dbsqlite

import (
	"context"
	"database/sql"
	"encoding/json"
)

const assignPublicKeyToNamespace = `-- name: AssignPublicKeyToNamespace :one
INSERT INTO attribute_namespace_public_key_map (namespace_id, key_access_server_key_id)
VALUES ($1, $2)
RETURNING namespace_id, key_access_server_key_id
`

type AssignPublicKeyToNamespaceParams struct {
	NamespaceID          sql.NullString `json:"namespace_id"`
	KeyAccessServerKeyID sql.NullString `json:"key_access_server_key_id"`
}

// AssignPublicKeyToNamespace
//
//	INSERT INTO attribute_namespace_public_key_map (namespace_id, key_access_server_key_id)
//	VALUES ($1, $2)
//	RETURNING namespace_id, key_access_server_key_id
func (q *Queries) AssignPublicKeyToNamespace(ctx context.Context, arg AssignPublicKeyToNamespaceParams) (AttributeNamespacePublicKeyMap, error) {
	row := q.db.QueryRowContext(ctx, assignPublicKeyToNamespace, arg.NamespaceID, arg.KeyAccessServerKeyID)
	var i AttributeNamespacePublicKeyMap
	err := row.Scan(&i.NamespaceID, &i.KeyAccessServerKeyID)
	return i, err
}

const createNamespace = `-- name: CreateNamespace :one
INSERT INTO attribute_namespaces (id, name, metadata, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'), STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'))
RETURNING id
`

type CreateNamespaceParams struct {
	Name     string         `json:"name"`
	Metadata sql.NullString `json:"metadata"`
}

// CreateNamespace
//
//	INSERT INTO attribute_namespaces (id, name, metadata, created_at, updated_at)
//	VALUES (gen_random_uuid(), $1, $2, STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'), STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'))
//	RETURNING id
func (q *Queries) CreateNamespace(ctx context.Context, arg CreateNamespaceParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createNamespace, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteNamespace = `-- name: DeleteNamespace :execrows
DELETE FROM attribute_namespaces WHERE id = $1
`

// DeleteNamespace
//
//	DELETE FROM attribute_namespaces WHERE id = $1
func (q *Queries) DeleteNamespace(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteNamespace, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getNamespace = `-- name: GetNamespace :one
SELECT
    ns.id,
    ns.name,
    ns.active,
    fqns.fqn,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(ns.metadata, '$.labels'), 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
    COALESCE(
        JSON_AGG(
            DISTINCT CASE
                WHEN kas_ns_grants.namespace_id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'id', kas.id,
                    'uri', kas.uri,
                    'name', kas.name,
                    'public_key', kas.public_key
                )
            END
        ),
        JSON_BUILD_ARRAY()
    ) as grants,
    COALESCE(nmp_keys.keys, JSON_BUILD_ARRAY()) as keys
FROM attribute_namespaces ns
LEFT JOIN attribute_namespace_key_access_grants kas_ns_grants ON kas_ns_grants.namespace_id = ns.id
LEFT JOIN key_access_servers kas ON kas.id = kas_ns_grants.key_access_server_id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = ns.id
LEFT JOIN (
    SELECT
        k.namespace_id,
        JSON_AGG(
            DISTINCT CASE
                WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'kas_uri', kas.uri,
                    'kas_id', kas.id,
                    'public_key', JSON_BUILD_OBJECT(
                         'algorithm', kask.key_algorithm,
                         'kid', kask.key_id,
                         'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
                    )
                )
            END
        ) AS keys
    FROM attribute_namespace_public_key_map k
    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
    GROUP BY k.namespace_id
) nmp_keys ON ns.id = nmp_keys.namespace_id
WHERE fqns.attribute_id IS NULL AND fqns.value_id IS NULL
  AND ($1 IS NULL OR ns.id = $1)
  AND ($2 IS NULL OR ns.name = REGEXP_REPLACE($2, '^https://', ''))
GROUP BY ns.id, fqns.fqn, nmp_keys.keys
`

type GetNamespaceParams struct {
	ID   interface{} `json:"id"`
	Name interface{} `json:"name"`
}

type GetNamespaceRow struct {
	ID       string          `json:"id"`
	Name     string          `json:"name"`
	Active   sql.NullBool    `json:"active"`
	Fqn      sql.NullString  `json:"fqn"`
	Metadata json.RawMessage `json:"metadata"`
	Grants   json.RawMessage `json:"grants"`
	Keys     json.RawMessage `json:"keys"`
}

// GetNamespace
//
//	SELECT
//	    ns.id,
//	    ns.name,
//	    ns.active,
//	    fqns.fqn,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(ns.metadata, '$.labels'), 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
//	    COALESCE(
//	        JSON_AGG(
//	            DISTINCT CASE
//	                WHEN kas_ns_grants.namespace_id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'id', kas.id,
//	                    'uri', kas.uri,
//	                    'name', kas.name,
//	                    'public_key', kas.public_key
//	                )
//	            END
//	        ),
//	        JSON_BUILD_ARRAY()
//	    ) as grants,
//	    COALESCE(nmp_keys.keys, JSON_BUILD_ARRAY()) as keys
//	FROM attribute_namespaces ns
//	LEFT JOIN attribute_namespace_key_access_grants kas_ns_grants ON kas_ns_grants.namespace_id = ns.id
//	LEFT JOIN key_access_servers kas ON kas.id = kas_ns_grants.key_access_server_id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = ns.id
//	LEFT JOIN (
//	    SELECT
//	        k.namespace_id,
//	        JSON_AGG(
//	            DISTINCT CASE
//	                WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'kas_uri', kas.uri,
//	                    'kas_id', kas.id,
//	                    'public_key', JSON_BUILD_OBJECT(
//	                         'algorithm', kask.key_algorithm,
//	                         'kid', kask.key_id,
//	                         'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
//	                    )
//	                )
//	            END
//	        ) AS keys
//	    FROM attribute_namespace_public_key_map k
//	    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	    GROUP BY k.namespace_id
//	) nmp_keys ON ns.id = nmp_keys.namespace_id
//	WHERE fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	  AND ($1 IS NULL OR ns.id = $1)
//	  AND ($2 IS NULL OR ns.name = REGEXP_REPLACE($2, '^https://', ''))
//	GROUP BY ns.id, fqns.fqn, nmp_keys.keys
func (q *Queries) GetNamespace(ctx context.Context, arg GetNamespaceParams) (GetNamespaceRow, error) {
	row := q.db.QueryRowContext(ctx, getNamespace, arg.ID, arg.Name)
	var i GetNamespaceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Active,
		&i.Fqn,
		&i.Metadata,
		&i.Grants,
		&i.Keys,
	)
	return i, err
}

const listNamespaces = `-- name: ListNamespaces :many

SELECT
    COUNT(*) OVER() AS total,
    ns.id,
    ns.name,
    ns.active,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(ns.metadata, '$.labels'), 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
    fqns.fqn
FROM attribute_namespaces ns
LEFT JOIN attribute_fqns fqns ON ns.id = fqns.namespace_id AND fqns.attribute_id IS NULL
WHERE ($1 IS NULL OR ns.active = $1)
ORDER BY ns.created_at DESC
LIMIT $3
OFFSET $2
`

type ListNamespacesParams struct {
	Active interface{} `json:"active"`
	Offset int32       `json:"offset_"`
	Limit  int32       `json:"limit_"`
}

type ListNamespacesRow struct {
	Total    int64           `json:"total"`
	ID       string          `json:"id"`
	Name     string          `json:"name"`
	Active   sql.NullBool    `json:"active"`
	Metadata json.RawMessage `json:"metadata"`
	Fqn      sql.NullString  `json:"fqn"`
}

// --------------------------------------------------------------
// NAMESPACES
// --------------------------------------------------------------
//
//	SELECT
//	    COUNT(*) OVER() AS total,
//	    ns.id,
//	    ns.name,
//	    ns.active,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(ns.metadata, '$.labels'), 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
//	    fqns.fqn
//	FROM attribute_namespaces ns
//	LEFT JOIN attribute_fqns fqns ON ns.id = fqns.namespace_id AND fqns.attribute_id IS NULL
//	WHERE ($1 IS NULL OR ns.active = $1)
//	ORDER BY ns.created_at DESC
//	LIMIT $3
//	OFFSET $2
func (q *Queries) ListNamespaces(ctx context.Context, arg ListNamespacesParams) ([]ListNamespacesRow, error) {
	rows, err := q.db.QueryContext(ctx, listNamespaces, arg.Active, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNamespacesRow
	for rows.Next() {
		var i ListNamespacesRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.Name,
			&i.Active,
			&i.Metadata,
			&i.Fqn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeKeyAccessServerFromNamespace = `-- name: RemoveKeyAccessServerFromNamespace :execrows
DELETE FROM attribute_namespace_key_access_grants
WHERE namespace_id = $1 AND key_access_server_id = $2
`

type RemoveKeyAccessServerFromNamespaceParams struct {
	NamespaceID       sql.NullString `json:"namespace_id"`
	KeyAccessServerID sql.NullString `json:"key_access_server_id"`
}

// RemoveKeyAccessServerFromNamespace
//
//	DELETE FROM attribute_namespace_key_access_grants
//	WHERE namespace_id = $1 AND key_access_server_id = $2
func (q *Queries) RemoveKeyAccessServerFromNamespace(ctx context.Context, arg RemoveKeyAccessServerFromNamespaceParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeKeyAccessServerFromNamespace, arg.NamespaceID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const removePublicKeyFromNamespace = `-- name: RemovePublicKeyFromNamespace :execrows
DELETE FROM attribute_namespace_public_key_map
WHERE namespace_id = $1 AND key_access_server_key_id = $2
`

type RemovePublicKeyFromNamespaceParams struct {
	NamespaceID          sql.NullString `json:"namespace_id"`
	KeyAccessServerKeyID sql.NullString `json:"key_access_server_key_id"`
}

// RemovePublicKeyFromNamespace
//
//	DELETE FROM attribute_namespace_public_key_map
//	WHERE namespace_id = $1 AND key_access_server_key_id = $2
func (q *Queries) RemovePublicKeyFromNamespace(ctx context.Context, arg RemovePublicKeyFromNamespaceParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removePublicKeyFromNamespace, arg.NamespaceID, arg.KeyAccessServerKeyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const rotatePublicKeyForNamespace = `-- name: RotatePublicKeyForNamespace :many
UPDATE attribute_namespace_public_key_map
SET key_access_server_key_id = $1
WHERE (key_access_server_key_id = $2)
RETURNING namespace_id
`

type RotatePublicKeyForNamespaceParams struct {
	NewKeyID sql.NullString `json:"new_key_id"`
	OldKeyID sql.NullString `json:"old_key_id"`
}

// RotatePublicKeyForNamespace
//
//	UPDATE attribute_namespace_public_key_map
//	SET key_access_server_key_id = $1
//	WHERE (key_access_server_key_id = $2)
//	RETURNING namespace_id
func (q *Queries) RotatePublicKeyForNamespace(ctx context.Context, arg RotatePublicKeyForNamespaceParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, rotatePublicKeyForNamespace, arg.NewKeyID, arg.OldKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var namespace_id sql.NullString
		if err := rows.Scan(&namespace_id); err != nil {
			return nil, err
		}
		items = append(items, namespace_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNamespace = `-- name: UpdateNamespace :execrows
UPDATE attribute_namespaces
SET
    name = COALESCE($2, name),
    active = COALESCE($3, active),
    metadata = COALESCE($4, metadata),
    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = $1
`

type UpdateNamespaceParams struct {
	ID       string         `json:"id"`
	Name     sql.NullString `json:"name"`
	Active   sql.NullBool   `json:"active"`
	Metadata sql.NullString `json:"metadata"`
}

// updateNamespace: both Safe and Unsafe Updates
//
//	UPDATE attribute_namespaces
//	SET
//	    name = COALESCE($2, name),
//	    active = COALESCE($3, active),
//	    metadata = COALESCE($4, metadata),
//	    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
//	WHERE id = $1
func (q *Queries) UpdateNamespace(ctx context.Context, arg UpdateNamespaceParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateNamespace,
		arg.ID,
		arg.Name,
		arg.Active,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
