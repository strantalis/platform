// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: key_access_server_registry.sql

package dbsqlite

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createKey = `-- name: CreateKey :one
INSERT INTO key_access_server_keys
    (id, key_access_server_id, key_algorithm, key_id, key_mode, key_status, metadata, private_key_ctx, public_key_ctx, provider_config_id, legacy, created_at, updated_at)
VALUES (
    gen_random_uuid(),
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'),
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
)
RETURNING id
`

type CreateKeyParams struct {
	KeyAccessServerID sql.NullString `json:"key_access_server_id"`
	KeyAlgorithm      sql.NullInt32  `json:"key_algorithm"`
	KeyID             sql.NullString `json:"key_id"`
	KeyMode           sql.NullInt32  `json:"key_mode"`
	KeyStatus         sql.NullInt32  `json:"key_status"`
	Metadata          sql.NullString `json:"metadata"`
	PrivateKeyCtx     sql.NullString `json:"private_key_ctx"`
	PublicKeyCtx      sql.NullString `json:"public_key_ctx"`
	ProviderConfigID  sql.NullString `json:"provider_config_id"`
	Legacy            sql.NullBool   `json:"legacy"`
}

// ---------------------------------------------------------------
// Key Access Server Keys
// ----------------------------------------------------------------
//
//	INSERT INTO key_access_server_keys
//	    (key_access_server_id, key_algorithm, key_id, key_mode, key_status, metadata, private_key_ctx, public_key_ctx, provider_config_id, legacy)
//	VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
//	RETURNING id
func (q *Queries) CreateKey(ctx context.Context, arg CreateKeyParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createKey,
		arg.KeyAccessServerID,
		arg.KeyAlgorithm,
		arg.KeyID,
		arg.KeyMode,
		arg.KeyStatus,
		arg.Metadata,
		arg.PrivateKeyCtx,
		arg.PublicKeyCtx,
		arg.ProviderConfigID,
		arg.Legacy,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createKeyAccessServer = `-- name: CreateKeyAccessServer :one
INSERT INTO key_access_servers (id, uri, public_key, name, metadata, source_type, created_at, updated_at)
VALUES (
    gen_random_uuid(),
    $1,
    $2,
    $3,
    $4,
    $5,
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'),
    STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
)
RETURNING id
`

type CreateKeyAccessServerParams struct {
	Uri        string         `json:"uri"`
	PublicKey  sql.NullString `json:"public_key"`
	Name       sql.NullString `json:"name"`
	Metadata   sql.NullString `json:"metadata"`
	SourceType sql.NullString `json:"source_type"`
}

// CreateKeyAccessServer
//
//	INSERT INTO key_access_servers (uri, public_key, name, metadata, source_type)
//	VALUES ($1, $2, $3, $4, $5)
//	RETURNING id
func (q *Queries) CreateKeyAccessServer(ctx context.Context, arg CreateKeyAccessServerParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createKeyAccessServer,
		arg.Uri,
		arg.PublicKey,
		arg.Name,
		arg.Metadata,
		arg.SourceType,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteKey = `-- name: DeleteKey :execrows
DELETE FROM key_access_server_keys WHERE id = $1
`

// DeleteKey
//
//	DELETE FROM key_access_server_keys WHERE id = $1
func (q *Queries) DeleteKey(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteKey, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteKeyAccessServer = `-- name: DeleteKeyAccessServer :execrows
DELETE FROM key_access_servers WHERE id = $1
`

// DeleteKeyAccessServer
//
//	DELETE FROM key_access_servers WHERE id = $1
func (q *Queries) DeleteKeyAccessServer(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteKeyAccessServer, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getBaseKey = `-- name: GetBaseKey :one

SELECT
    DISTINCT JSON_BUILD_OBJECT(
       'kas_uri', kas.uri,
       'kas_id', kas.id,
       'public_key', JSON_BUILD_OBJECT(
            'algorithm', kask.key_algorithm,
            'kid', kask.key_id,
            'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
       )
    ) AS base_keys
FROM base_keys bk
INNER JOIN key_access_server_keys kask ON bk.key_access_server_key_id = kask.id
INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
`

// --------------------------------------------------------------
// Default KAS Keys
// --------------------------------------------------------------
//
//	SELECT
//	    DISTINCT JSON_BUILD_OBJECT(
//	       'kas_uri', kas.uri,
//	       'kas_id', kas.id,
//	       'public_key', JSON_BUILD_OBJECT(
//	            'algorithm', kask.key_algorithm,
//	            'kid', kask.key_id,
//	            'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
//	       )
//	    ) AS base_keys
//	FROM base_keys bk
//	INNER JOIN key_access_server_keys kask ON bk.key_access_server_key_id = kask.id
//	INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
func (q *Queries) GetBaseKey(ctx context.Context) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getBaseKey)
	var base_keys json.RawMessage
	err := row.Scan(&base_keys)
	return base_keys, err
}

const getKey = `-- name: GetKey :one
WITH params AS (
    SELECT
        $1 as id,
        $2 as key_id,
        $3 as kas_id,
        $4 as kas_uri,
        $5 as kas_name
)
SELECT 
  kask.id,
  kask.key_id,
  kask.key_status,
  kask.key_mode,
  kask.key_algorithm,
  kask.private_key_ctx,
  kask.public_key_ctx,
  kask.provider_config_id,
  kask.key_access_server_id,
  kas.uri AS kas_uri,
  JSON_STRIP_NULLS(
    JSON_BUILD_OBJECT(
      'labels', json_extract(kask.metadata, '$.labels'),         
      'created_at', kask.created_at,               
      'updated_at', kask.updated_at                
    )
  ) AS metadata,
  pc.manager AS pc_manager,
  pc.provider_name,
  pc.config AS pc_config,
  JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(pc.metadata, '$.labels'), 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS pc_metadata,
  kask.legacy
FROM key_access_server_keys AS kask
LEFT JOIN 
    provider_config as pc ON kask.provider_config_id = pc.id
INNER JOIN 
    key_access_servers AS kas ON kask.key_access_server_id = kas.id
WHERE ($1 IS NULL OR kask.id = $1)
  AND ($2 IS NULL OR kask.key_id = $2)
  AND ($3 IS NULL OR kask.key_access_server_id = $3)
  AND ($4 IS NULL OR kas.uri = $4)
  AND ($5 IS NULL OR kas.name = $5)
`

type GetKeyParams struct {
	ID      interface{} `json:"id"`
	KeyID   interface{} `json:"key_id"`
	KasID   interface{} `json:"kas_id"`
	KasUri  interface{} `json:"kas_uri"`
	KasName interface{} `json:"kas_name"`
}

type GetKeyRow struct {
	ID                string          `json:"id"`
	KeyID             sql.NullString  `json:"key_id"`
	KeyStatus         sql.NullInt32   `json:"key_status"`
	KeyMode           sql.NullInt32   `json:"key_mode"`
	KeyAlgorithm      sql.NullInt32   `json:"key_algorithm"`
	PrivateKeyCtx     sql.NullString  `json:"private_key_ctx"`
	PublicKeyCtx      sql.NullString  `json:"public_key_ctx"`
	ProviderConfigID  sql.NullString  `json:"provider_config_id"`
	KeyAccessServerID sql.NullString  `json:"key_access_server_id"`
	KasUri            string          `json:"kas_uri"`
	Metadata          json.RawMessage `json:"metadata"`
	PcManager         sql.NullString  `json:"pc_manager"`
	ProviderName      sql.NullString  `json:"provider_name"`
	PcConfig          sql.NullString  `json:"pc_config"`
	PcMetadata        json.RawMessage `json:"pc_metadata"`
	Legacy            sql.NullBool    `json:"legacy"`
}

// GetKey
//
//	WITH params AS (
//	    SELECT
//	        $1 as id,
//	        $2 as key_id,
//	        $3 as kas_id,
//	        $4 as kas_uri,
//	        $5 as kas_name
//	)
//	SELECT
//	  kask.id,
//	  kask.key_id,
//	  kask.key_status,
//	  kask.key_mode,
//	  kask.key_algorithm,
//	  kask.private_key_ctx,
//	  kask.public_key_ctx,
//	  kask.provider_config_id,
//	  kask.key_access_server_id,
//	  kas.uri AS kas_uri,
//	  JSON_STRIP_NULLS(
//	    JSON_BUILD_OBJECT(
//	      'labels', json_extract(kask.metadata, '$.labels'),
//	      'created_at', kask.created_at,
//	      'updated_at', kask.updated_at
//	    )
//	  ) AS metadata,
//	  pc.manager AS pc_manager,
//	  pc.provider_name,
//	  pc.config AS pc_config,
//	  JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(pc.metadata, '$.labels'), 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS pc_metadata,
//	  kask.legacy
//	FROM key_access_server_keys AS kask
//	LEFT JOIN
//	    provider_config as pc ON kask.provider_config_id = pc.id
//	INNER JOIN
//	    key_access_servers AS kas ON kask.key_access_server_id = kas.id
//	WHERE ($1 IS NULL OR kask.id = $1)
//	  AND ($2 IS NULL OR kask.key_id = $2)
//	  AND ($3 IS NULL OR kask.key_access_server_id = $3)
//	  AND ($4 IS NULL OR kas.uri = $4)
//	  AND ($5 IS NULL OR kas.name = $5)
func (q *Queries) GetKey(ctx context.Context, arg GetKeyParams) (GetKeyRow, error) {
	row := q.db.QueryRowContext(ctx, getKey,
		arg.ID,
		arg.KeyID,
		arg.KasID,
		arg.KasUri,
		arg.KasName,
	)
	var i GetKeyRow
	err := row.Scan(
		&i.ID,
		&i.KeyID,
		&i.KeyStatus,
		&i.KeyMode,
		&i.KeyAlgorithm,
		&i.PrivateKeyCtx,
		&i.PublicKeyCtx,
		&i.ProviderConfigID,
		&i.KeyAccessServerID,
		&i.KasUri,
		&i.Metadata,
		&i.PcManager,
		&i.ProviderName,
		&i.PcConfig,
		&i.PcMetadata,
		&i.Legacy,
	)
	return i, err
}

const getKeyAccessServer = `-- name: GetKeyAccessServer :one
SELECT 
    kas.id,
    kas.uri, 
    kas.public_key, 
    kas.name,
    kas.source_type,
    JSON_STRIP_NULLS(
        JSON_BUILD_OBJECT(
            'labels', json_extract(metadata, '$.labels'), 
            'created_at', created_at, 
            'updated_at', updated_at
        )
    ) AS metadata,
    kask_keys.keys
FROM key_access_servers AS kas
LEFT JOIN (
        SELECT
            kask.key_access_server_id,
            JSON_AGG(
                DISTINCT CASE
                    WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                        'kas_uri', kas.uri,
                        'kas_id', kas.id,
                        'public_key', JSON_BUILD_OBJECT(
                             'algorithm', kask.key_algorithm,
                             'kid', kask.key_id,
                             'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
                        )
                    )
                END
            ) AS keys
        FROM key_access_server_keys kask
        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
        GROUP BY kask.key_access_server_id
    ) kask_keys ON kas.id = kask_keys.key_access_server_id
WHERE ($1 IS NULL OR kas.id = $1)
  AND ($2 IS NULL OR kas.name = $2)
  AND ($3 IS NULL OR kas.uri = $3)
`

type GetKeyAccessServerParams struct {
	ID   interface{} `json:"id"`
	Name interface{} `json:"name"`
	Uri  interface{} `json:"uri"`
}

type GetKeyAccessServerRow struct {
	ID         string          `json:"id"`
	Uri        string          `json:"uri"`
	PublicKey  sql.NullString  `json:"public_key"`
	Name       sql.NullString  `json:"name"`
	SourceType sql.NullString  `json:"source_type"`
	Metadata   json.RawMessage `json:"metadata"`
	Keys       json.RawMessage `json:"keys"`
}

// GetKeyAccessServer
//
//	SELECT
//	    kas.id,
//	    kas.uri,
//	    kas.public_key,
//	    kas.name,
//	    kas.source_type,
//	    JSON_STRIP_NULLS(
//	        JSON_BUILD_OBJECT(
//	            'labels', json_extract(metadata, '$.labels'),
//	            'created_at', created_at,
//	            'updated_at', updated_at
//	        )
//	    ) AS metadata,
//	    kask_keys.keys
//	FROM key_access_servers AS kas
//	LEFT JOIN (
//	        SELECT
//	            kask.key_access_server_id,
//	            JSON_AGG(
//	                DISTINCT CASE
//	                    WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                        'kas_uri', kas.uri,
//	                        'kas_id', kas.id,
//	                        'public_key', JSON_BUILD_OBJECT(
//	                             'algorithm', kask.key_algorithm,
//	                             'kid', kask.key_id,
//	                             'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
//	                        )
//	                    )
//	                END
//	            ) AS keys
//	        FROM key_access_server_keys kask
//	        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	        GROUP BY kask.key_access_server_id
//	    ) kask_keys ON kas.id = kask_keys.key_access_server_id
//	WHERE ($1 IS NULL OR kas.id = $1)
//	  AND ($2 IS NULL OR kas.name = $2)
//	  AND ($3 IS NULL OR kas.uri = $3)
func (q *Queries) GetKeyAccessServer(ctx context.Context, arg GetKeyAccessServerParams) (GetKeyAccessServerRow, error) {
	row := q.db.QueryRowContext(ctx, getKeyAccessServer, arg.ID, arg.Name, arg.Uri)
	var i GetKeyAccessServerRow
	err := row.Scan(
		&i.ID,
		&i.Uri,
		&i.PublicKey,
		&i.Name,
		&i.SourceType,
		&i.Metadata,
		&i.Keys,
	)
	return i, err
}

const keyAccessServerExists = `-- name: KeyAccessServerExists :one
SELECT COUNT(*) > 0 AS exists_flag
FROM key_access_servers AS kas
WHERE ($1 IS NULL OR kas.id = $1)
    AND ($2 IS NULL OR kas.name = $2)
    AND ($3 IS NULL OR kas.uri = $3)
`

type KeyAccessServerExistsParams struct {
	KasID   interface{} `json:"kas_id"`
	KasName interface{} `json:"kas_name"`
	KasUri  interface{} `json:"kas_uri"`
}

// KeyAccessServerExists
//
//	SELECT COUNT(*) > 0 AS exists_flag
//	FROM key_access_servers AS kas
//	WHERE ($1 IS NULL OR kas.id = $1)
//	    AND ($2 IS NULL OR kas.name = $2)
//	    AND ($3 IS NULL OR kas.uri = $3)
func (q *Queries) KeyAccessServerExists(ctx context.Context, arg KeyAccessServerExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, keyAccessServerExists, arg.KasID, arg.KasName, arg.KasUri)
	var exists_flag bool
	err := row.Scan(&exists_flag)
	return exists_flag, err
}

const listKeyAccessServerGrants = `-- name: ListKeyAccessServerGrants :many
WITH listed AS (
    SELECT
        COUNT(*) OVER () AS total,
        kas.id AS kas_id,
        kas.uri AS kas_uri,
        kas.name AS kas_name,
        kas.public_key AS kas_public_key,
        JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
            'labels', json_extract(kas.metadata, '$.labels'),
            'created_at', kas.created_at,
            'updated_at', kas.updated_at
        )) AS kas_metadata,
        JSON_AGG(
            DISTINCT CASE
                WHEN attrkag.attribute_definition_id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'id', attrkag.attribute_definition_id,
                    'fqn', fqns_on_attr.fqn
                )
            END
        ) AS attributes_grants,
        JSON_AGG(
            DISTINCT CASE
                WHEN valkag.attribute_value_id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'id', valkag.attribute_value_id,
                    'fqn', fqns_on_vals.fqn
                )
            END
        ) AS values_grants,
        JSON_AGG(
            DISTINCT CASE
                WHEN nskag.namespace_id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'id', nskag.namespace_id,
                    'fqn', fqns_on_ns.fqn
                )
            END
        ) AS namespace_grants
    FROM key_access_servers AS kas
    LEFT JOIN
        attribute_definition_key_access_grants AS attrkag
        ON kas.id = attrkag.key_access_server_id
    LEFT JOIN
        attribute_fqns AS fqns_on_attr
        ON attrkag.attribute_definition_id = fqns_on_attr.attribute_id
            AND fqns_on_attr.value_id IS NULL
    LEFT JOIN
        attribute_value_key_access_grants AS valkag
        ON kas.id = valkag.key_access_server_id
    LEFT JOIN 
        attribute_fqns AS fqns_on_vals
        ON valkag.attribute_value_id = fqns_on_vals.value_id
    LEFT JOIN
        attribute_namespace_key_access_grants AS nskag
        ON kas.id = nskag.key_access_server_id
    LEFT JOIN
        attribute_fqns AS fqns_on_ns
            ON nskag.namespace_id = fqns_on_ns.namespace_id
        AND fqns_on_ns.attribute_id IS NULL AND fqns_on_ns.value_id IS NULL
    WHERE ($3 IS NULL OR kas.id = $3) 
        AND ($4 IS NULL OR kas.uri = $4) 
        AND ($5 IS NULL OR kas.name = $5) 
    GROUP BY 
        kas.id
)
SELECT 
    listed.kas_id,
    listed.kas_uri,
    listed.kas_name,
    listed.kas_public_key,
    listed.kas_metadata,
    listed.attributes_grants,
    listed.values_grants,
    listed.namespace_grants,
    listed.total  
FROM listed
LIMIT $2 
OFFSET $1
`

type ListKeyAccessServerGrantsParams struct {
	Offset  int32       `json:"offset_"`
	Limit   int32       `json:"limit_"`
	KasID   interface{} `json:"kas_id"`
	KasUri  interface{} `json:"kas_uri"`
	KasName interface{} `json:"kas_name"`
}

type ListKeyAccessServerGrantsRow struct {
	KasID            string          `json:"kas_id"`
	KasUri           string          `json:"kas_uri"`
	KasName          sql.NullString  `json:"kas_name"`
	KasPublicKey     sql.NullString  `json:"kas_public_key"`
	KasMetadata      json.RawMessage `json:"kas_metadata"`
	AttributesGrants json.RawMessage `json:"attributes_grants"`
	ValuesGrants     json.RawMessage `json:"values_grants"`
	NamespaceGrants  json.RawMessage `json:"namespace_grants"`
	Total            int64           `json:"total"`
}

// --------------------------------------------------------------
// KEY ACCESS SERVERS
// --------------------------------------------------------------
//
//	WITH listed AS (
//	    SELECT
//	        COUNT(*) OVER () AS total,
//	        kas.id AS kas_id,
//	        kas.uri AS kas_uri,
//	        kas.name AS kas_name,
//	        kas.public_key AS kas_public_key,
//	        JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	            'labels', json_extract(kas.metadata, '$.labels'),
//	            'created_at', kas.created_at,
//	            'updated_at', kas.updated_at
//	        )) AS kas_metadata,
//	        JSON_AGG(
//	            DISTINCT CASE
//	                WHEN attrkag.attribute_definition_id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'id', attrkag.attribute_definition_id,
//	                    'fqn', fqns_on_attr.fqn
//	                )
//	            END
//	        ) AS attributes_grants,
//	        JSON_AGG(
//	            DISTINCT CASE
//	                WHEN valkag.attribute_value_id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'id', valkag.attribute_value_id,
//	                    'fqn', fqns_on_vals.fqn
//	                )
//	            END
//	        ) AS values_grants,
//	        JSON_AGG(
//	            DISTINCT CASE
//	                WHEN nskag.namespace_id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'id', nskag.namespace_id,
//	                    'fqn', fqns_on_ns.fqn
//	                )
//	            END
//	        ) AS namespace_grants
//	    FROM key_access_servers AS kas
//	    LEFT JOIN
//	        attribute_definition_key_access_grants AS attrkag
//	        ON kas.id = attrkag.key_access_server_id
//	    LEFT JOIN
//	        attribute_fqns AS fqns_on_attr
//	        ON attrkag.attribute_definition_id = fqns_on_attr.attribute_id
//	            AND fqns_on_attr.value_id IS NULL
//	    LEFT JOIN
//	        attribute_value_key_access_grants AS valkag
//	        ON kas.id = valkag.key_access_server_id
//	    LEFT JOIN
//	        attribute_fqns AS fqns_on_vals
//	        ON valkag.attribute_value_id = fqns_on_vals.value_id
//	    LEFT JOIN
//	        attribute_namespace_key_access_grants AS nskag
//	        ON kas.id = nskag.key_access_server_id
//	    LEFT JOIN
//	        attribute_fqns AS fqns_on_ns
//	            ON nskag.namespace_id = fqns_on_ns.namespace_id
//	        AND fqns_on_ns.attribute_id IS NULL AND fqns_on_ns.value_id IS NULL
//	    WHERE ($3 IS NULL OR kas.id = $3)
//	        AND ($4 IS NULL OR kas.uri = $4)
//	        AND ($5 IS NULL OR kas.name = $5)
//	    GROUP BY
//	        kas.id
//	)
//	SELECT
//	    listed.kas_id,
//	    listed.kas_uri,
//	    listed.kas_name,
//	    listed.kas_public_key,
//	    listed.kas_metadata,
//	    listed.attributes_grants,
//	    listed.values_grants,
//	    listed.namespace_grants,
//	    listed.total
//	FROM listed
//	LIMIT $2
//	OFFSET $1
func (q *Queries) ListKeyAccessServerGrants(ctx context.Context, arg ListKeyAccessServerGrantsParams) ([]ListKeyAccessServerGrantsRow, error) {
	rows, err := q.db.QueryContext(ctx, listKeyAccessServerGrants,
		arg.Offset,
		arg.Limit,
		arg.KasID,
		arg.KasUri,
		arg.KasName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeyAccessServerGrantsRow
	for rows.Next() {
		var i ListKeyAccessServerGrantsRow
		if err := rows.Scan(
			&i.KasID,
			&i.KasUri,
			&i.KasName,
			&i.KasPublicKey,
			&i.KasMetadata,
			&i.AttributesGrants,
			&i.ValuesGrants,
			&i.NamespaceGrants,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeyAccessServers = `-- name: ListKeyAccessServers :many
WITH counted AS (
    SELECT COUNT(kas.id) AS total
    FROM key_access_servers AS kas
)
SELECT kas.id,
    kas.uri,
    kas.public_key,
    kas.name AS kas_name,
    kas.source_type,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(kas.metadata, '$.labels'), 'created_at', kas.created_at, 'updated_at', kas.updated_at)) AS metadata,
    kask_keys.keys,
    counted.total
FROM key_access_servers AS kas
CROSS JOIN counted
LEFT JOIN (
        SELECT
            kask.key_access_server_id,
            JSON_AGG(
                DISTINCT CASE
                    WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
                        'kas_uri', kas.uri,
                        'kas_id', kas.id,
                        'public_key', JSON_BUILD_OBJECT(
                             'algorithm', kask.key_algorithm,
                             'kid', kask.key_id,
                             'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
                        )
                    )
                END
            ) AS keys
        FROM key_access_server_keys kask
        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
        GROUP BY kask.key_access_server_id
    ) kask_keys ON kas.id = kask_keys.key_access_server_id
ORDER BY kas.created_at DESC
LIMIT $2 
OFFSET $1
`

type ListKeyAccessServersParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type ListKeyAccessServersRow struct {
	ID         string          `json:"id"`
	Uri        string          `json:"uri"`
	PublicKey  sql.NullString  `json:"public_key"`
	KasName    sql.NullString  `json:"kas_name"`
	SourceType sql.NullString  `json:"source_type"`
	Metadata   json.RawMessage `json:"metadata"`
	Keys       json.RawMessage `json:"keys"`
	Total      int64           `json:"total"`
}

// ListKeyAccessServers
//
//	WITH counted AS (
//	    SELECT COUNT(kas.id) AS total
//	    FROM key_access_servers AS kas
//	)
//	SELECT kas.id,
//	    kas.uri,
//	    kas.public_key,
//	    kas.name AS kas_name,
//	    kas.source_type,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(kas.metadata, '$.labels'), 'created_at', kas.created_at, 'updated_at', kas.updated_at)) AS metadata,
//	    kask_keys.keys,
//	    counted.total
//	FROM key_access_servers AS kas
//	CROSS JOIN counted
//	LEFT JOIN (
//	        SELECT
//	            kask.key_access_server_id,
//	            JSON_AGG(
//	                DISTINCT CASE
//	                    WHEN kask.id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                        'kas_uri', kas.uri,
//	                        'kas_id', kas.id,
//	                        'public_key', JSON_BUILD_OBJECT(
//	                             'algorithm', kask.key_algorithm,
//	                             'kid', kask.key_id,
//	                             'pem', CONVERT_FROM(DECODE(json_extract(kask.public_key_ctx, '$.pem'), 'base64'), 'UTF8')
//	                        )
//	                    )
//	                END
//	            ) AS keys
//	        FROM key_access_server_keys kask
//	        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	        GROUP BY kask.key_access_server_id
//	    ) kask_keys ON kas.id = kask_keys.key_access_server_id
//	ORDER BY kas.created_at DESC
//	LIMIT $2
//	OFFSET $1
func (q *Queries) ListKeyAccessServers(ctx context.Context, arg ListKeyAccessServersParams) ([]ListKeyAccessServersRow, error) {
	rows, err := q.db.QueryContext(ctx, listKeyAccessServers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeyAccessServersRow
	for rows.Next() {
		var i ListKeyAccessServersRow
		if err := rows.Scan(
			&i.ID,
			&i.Uri,
			&i.PublicKey,
			&i.KasName,
			&i.SourceType,
			&i.Metadata,
			&i.Keys,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeyMappings = `-- name: ListKeyMappings :many
WITH filtered_keys AS (
    -- Get all keys matching the filter criteria
    SELECT
        kask.created_at,
        kask.id AS id,
        kask.key_id AS kid,
        kas.id AS kas_id,
        kas.uri AS kas_uri
    FROM key_access_server_keys kask
    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
    WHERE (
        -- Case 1: Filter by system key ID if provided
        ($3 IS NOT NULL AND kask.id = $3)
        -- Case 2: Filter by KID + at least one KAS identifier
        OR (
            $4 IS NOT NULL 
            AND kask.key_id = $4
            AND (
                ($5 IS NOT NULL AND kas.id = $5)
                OR ($6 IS NOT NULL AND kas.name = $6)
                OR ($7 IS NOT NULL AND kas.uri = $7)
            )
        )
        -- Case 3: Return all keys if no filters are provided
        OR (
            $3 IS NULL 
            AND $4 IS NULL
        )
    )
),
keys_with_mappings AS (
    SELECT id
    FROM filtered_keys fk
    WHERE EXISTS (
        SELECT 1 FROM attribute_namespace_public_key_map anpm WHERE anpm.key_access_server_key_id = fk.id
    ) OR EXISTS (
        SELECT 1 FROM attribute_definition_public_key_map adpm WHERE adpm.key_access_server_key_id = fk.id
    ) OR EXISTS (
        SELECT 1 FROM attribute_value_public_key_map avpm WHERE avpm.key_access_server_key_id = fk.id
    )
),
keys_with_mappings_count AS (
    SELECT COUNT(*) AS total FROM keys_with_mappings
),
namespace_mappings AS (
    -- Get namespace mappings for each key
    SELECT 
        fk.id as key_id,
        JSON_AGG(
            CASE
                WHEN anpm.namespace_id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'id', anpm.namespace_id,
                    'fqn', fqns.fqn
                )
            END
        ) AS namespace_mappings
    FROM filtered_keys fk
    INNER JOIN attribute_namespace_public_key_map anpm ON fk.id = anpm.key_access_server_key_id
    INNER JOIN attribute_fqns fqns ON anpm.namespace_id = fqns.namespace_id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
    GROUP BY fk.id
),
definition_mappings AS (
    -- Get attribute definition mappings for each key
    SELECT 
        fk.id as key_id,
        JSON_AGG(
            CASE
                WHEN adpm.definition_id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'id', adpm.definition_id,
                    'fqn', fqns.fqn
                )
            END
        ) AS definition_mappings
    FROM filtered_keys fk
    INNER JOIN attribute_definition_public_key_map adpm ON fk.id = adpm.key_access_server_key_id
    INNER JOIN attribute_fqns fqns ON adpm.definition_id = fqns.attribute_id AND fqns.value_id IS NULL
    GROUP BY fk.id
),
value_mappings AS (
    -- Get attribute value mappings for each key
    SELECT 
        fk.id as key_id,
        JSON_AGG(
            CASE
                WHEN avpm.value_id IS NOT NULL THEN JSON_BUILD_OBJECT(
                    'id', avpm.value_id,
                    'fqn', fqns.fqn
                )
            END
        ) AS value_mappings
    FROM filtered_keys fk
    INNER JOIN attribute_value_public_key_map avpm ON fk.id = avpm.key_access_server_key_id
    INNER JOIN attribute_fqns fqns ON avpm.value_id = fqns.value_id
    GROUP BY fk.id
)
SELECT 
    fk.kid,
    fk.kas_uri,
    COALESCE(nm.namespace_mappings, '[]') AS namespace_mappings,
    COALESCE(dm.definition_mappings, '[]') AS attribute_mappings,
    COALESCE(vm.value_mappings, '[]') AS value_mappings,
    kwmc.total
FROM filtered_keys fk
INNER JOIN keys_with_mappings kwm ON fk.id = kwm.id
CROSS JOIN keys_with_mappings_count kwmc
LEFT JOIN namespace_mappings nm ON fk.id = nm.key_id
LEFT JOIN definition_mappings dm ON fk.id = dm.key_id
LEFT JOIN value_mappings vm ON fk.id = vm.key_id
ORDER BY fk.created_at DESC
LIMIT $2 
OFFSET $1
`

type ListKeyMappingsParams struct {
	Offset  int32       `json:"offset_"`
	Limit   int32       `json:"limit_"`
	ID      interface{} `json:"id"`
	Kid     interface{} `json:"kid"`
	KasID   interface{} `json:"kas_id"`
	KasName interface{} `json:"kas_name"`
	KasUri  interface{} `json:"kas_uri"`
}

type ListKeyMappingsRow struct {
	Kid               sql.NullString  `json:"kid"`
	KasUri            string          `json:"kas_uri"`
	NamespaceMappings json.RawMessage `json:"namespace_mappings"`
	AttributeMappings json.RawMessage `json:"attribute_mappings"`
	ValueMappings     json.RawMessage `json:"value_mappings"`
	Total             int64           `json:"total"`
}

// ListKeyMappings
//
//	WITH filtered_keys AS (
//	    -- Get all keys matching the filter criteria
//	    SELECT
//	        kask.created_at,
//	        kask.id AS id,
//	        kask.key_id AS kid,
//	        kas.id AS kas_id,
//	        kas.uri AS kas_uri
//	    FROM key_access_server_keys kask
//	    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	    WHERE (
//	        -- Case 1: Filter by system key ID if provided
//	        ($3 IS NOT NULL AND kask.id = $3)
//	        -- Case 2: Filter by KID + at least one KAS identifier
//	        OR (
//	            $4 IS NOT NULL
//	            AND kask.key_id = $4
//	            AND (
//	                ($5 IS NOT NULL AND kas.id = $5)
//	                OR ($6 IS NOT NULL AND kas.name = $6)
//	                OR ($7 IS NOT NULL AND kas.uri = $7)
//	            )
//	        )
//	        -- Case 3: Return all keys if no filters are provided
//	        OR (
//	            $3 IS NULL
//	            AND $4 IS NULL
//	        )
//	    )
//	),
//	keys_with_mappings AS (
//	    SELECT id
//	    FROM filtered_keys fk
//	    WHERE EXISTS (
//	        SELECT 1 FROM attribute_namespace_public_key_map anpm WHERE anpm.key_access_server_key_id = fk.id
//	    ) OR EXISTS (
//	        SELECT 1 FROM attribute_definition_public_key_map adpm WHERE adpm.key_access_server_key_id = fk.id
//	    ) OR EXISTS (
//	        SELECT 1 FROM attribute_value_public_key_map avpm WHERE avpm.key_access_server_key_id = fk.id
//	    )
//	),
//	keys_with_mappings_count AS (
//	    SELECT COUNT(*) AS total FROM keys_with_mappings
//	),
//	namespace_mappings AS (
//	    -- Get namespace mappings for each key
//	    SELECT
//	        fk.id as key_id,
//	        JSON_AGG(
//	            CASE
//	                WHEN anpm.namespace_id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'id', anpm.namespace_id,
//	                    'fqn', fqns.fqn
//	                )
//	            END
//	        ) AS namespace_mappings
//	    FROM filtered_keys fk
//	    INNER JOIN attribute_namespace_public_key_map anpm ON fk.id = anpm.key_access_server_key_id
//	    INNER JOIN attribute_fqns fqns ON anpm.namespace_id = fqns.namespace_id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	    GROUP BY fk.id
//	),
//	definition_mappings AS (
//	    -- Get attribute definition mappings for each key
//	    SELECT
//	        fk.id as key_id,
//	        JSON_AGG(
//	            CASE
//	                WHEN adpm.definition_id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'id', adpm.definition_id,
//	                    'fqn', fqns.fqn
//	                )
//	            END
//	        ) AS definition_mappings
//	    FROM filtered_keys fk
//	    INNER JOIN attribute_definition_public_key_map adpm ON fk.id = adpm.key_access_server_key_id
//	    INNER JOIN attribute_fqns fqns ON adpm.definition_id = fqns.attribute_id AND fqns.value_id IS NULL
//	    GROUP BY fk.id
//	),
//	value_mappings AS (
//	    -- Get attribute value mappings for each key
//	    SELECT
//	        fk.id as key_id,
//	        JSON_AGG(
//	            CASE
//	                WHEN avpm.value_id IS NOT NULL THEN JSON_BUILD_OBJECT(
//	                    'id', avpm.value_id,
//	                    'fqn', fqns.fqn
//	                )
//	            END
//	        ) AS value_mappings
//	    FROM filtered_keys fk
//	    INNER JOIN attribute_value_public_key_map avpm ON fk.id = avpm.key_access_server_key_id
//	    INNER JOIN attribute_fqns fqns ON avpm.value_id = fqns.value_id
//	    GROUP BY fk.id
//	)
//	SELECT
//	    fk.kid,
//	    fk.kas_uri,
//	    COALESCE(nm.namespace_mappings, '[]') AS namespace_mappings,
//	    COALESCE(dm.definition_mappings, '[]') AS attribute_mappings,
//	    COALESCE(vm.value_mappings, '[]') AS value_mappings,
//	    kwmc.total
//	FROM filtered_keys fk
//	INNER JOIN keys_with_mappings kwm ON fk.id = kwm.id
//	CROSS JOIN keys_with_mappings_count kwmc
//	LEFT JOIN namespace_mappings nm ON fk.id = nm.key_id
//	LEFT JOIN definition_mappings dm ON fk.id = dm.key_id
//	LEFT JOIN value_mappings vm ON fk.id = vm.key_id
//	ORDER BY fk.created_at DESC
//	LIMIT $2
//	OFFSET $1
func (q *Queries) ListKeyMappings(ctx context.Context, arg ListKeyMappingsParams) ([]ListKeyMappingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listKeyMappings,
		arg.Offset,
		arg.Limit,
		arg.ID,
		arg.Kid,
		arg.KasID,
		arg.KasName,
		arg.KasUri,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeyMappingsRow
	for rows.Next() {
		var i ListKeyMappingsRow
		if err := rows.Scan(
			&i.Kid,
			&i.KasUri,
			&i.NamespaceMappings,
			&i.AttributeMappings,
			&i.ValueMappings,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeys = `-- name: ListKeys :many
WITH listed AS (
    SELECT
        kas.id AS kas_id,
        kas.uri AS kas_uri
    FROM key_access_servers AS kas
    WHERE ($5 IS NULL OR kas.id = $5)
            AND ($6 IS NULL OR kas.name = $6)
            AND ($7 IS NULL OR kas.uri = $7)
)
SELECT 
  COUNT(*) OVER () AS total,
  kask.id,
  kask.key_id,
  kask.key_status,
  kask.key_mode,
  kask.key_algorithm,
  kask.private_key_ctx,
  kask.public_key_ctx,
  kask.provider_config_id,
  kask.key_access_server_id,
  listed.kas_uri AS kas_uri,
  JSON_STRIP_NULLS(
    JSON_BUILD_OBJECT(
      'labels', json_extract(kask.metadata, '$.labels'),         
      'created_at', kask.created_at,               
      'updated_at', kask.updated_at                
    )
  ) AS metadata,
  pc.provider_name,
  pc.config AS provider_config,
  JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(pc.metadata, '$.labels'), 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS pc_metadata,
  kask.legacy
FROM key_access_server_keys AS kask
INNER JOIN
    listed ON kask.key_access_server_id = listed.kas_id
LEFT JOIN 
    provider_config as pc ON kask.provider_config_id = pc.id
WHERE
    ($1 IS NULL OR kask.key_algorithm = $1)
    AND ($2 IS NULL OR kask.legacy = $2)
ORDER BY kask.created_at DESC
LIMIT $4 
OFFSET $3
`

type ListKeysParams struct {
	KeyAlgorithm interface{} `json:"key_algorithm"`
	Legacy       interface{} `json:"legacy"`
	Offset       int32       `json:"offset_"`
	Limit        int32       `json:"limit_"`
	KasID        interface{} `json:"kas_id"`
	KasName      interface{} `json:"kas_name"`
	KasUri       interface{} `json:"kas_uri"`
}

type ListKeysRow struct {
	Total             int64           `json:"total"`
	ID                string          `json:"id"`
	KeyID             sql.NullString  `json:"key_id"`
	KeyStatus         sql.NullInt32   `json:"key_status"`
	KeyMode           sql.NullInt32   `json:"key_mode"`
	KeyAlgorithm      sql.NullInt32   `json:"key_algorithm"`
	PrivateKeyCtx     sql.NullString  `json:"private_key_ctx"`
	PublicKeyCtx      sql.NullString  `json:"public_key_ctx"`
	ProviderConfigID  sql.NullString  `json:"provider_config_id"`
	KeyAccessServerID sql.NullString  `json:"key_access_server_id"`
	KasUri            string          `json:"kas_uri"`
	Metadata          json.RawMessage `json:"metadata"`
	ProviderName      sql.NullString  `json:"provider_name"`
	ProviderConfig    sql.NullString  `json:"provider_config"`
	PcMetadata        json.RawMessage `json:"pc_metadata"`
	Legacy            sql.NullBool    `json:"legacy"`
}

// ListKeys
//
//	WITH listed AS (
//	    SELECT
//	        kas.id AS kas_id,
//	        kas.uri AS kas_uri
//	    FROM key_access_servers AS kas
//	    WHERE ($5 IS NULL OR kas.id = $5)
//	            AND ($6 IS NULL OR kas.name = $6)
//	            AND ($7 IS NULL OR kas.uri = $7)
//	)
//	SELECT
//	  COUNT(*) OVER () AS total,
//	  kask.id,
//	  kask.key_id,
//	  kask.key_status,
//	  kask.key_mode,
//	  kask.key_algorithm,
//	  kask.private_key_ctx,
//	  kask.public_key_ctx,
//	  kask.provider_config_id,
//	  kask.key_access_server_id,
//	  listed.kas_uri AS kas_uri,
//	  JSON_STRIP_NULLS(
//	    JSON_BUILD_OBJECT(
//	      'labels', json_extract(kask.metadata, '$.labels'),
//	      'created_at', kask.created_at,
//	      'updated_at', kask.updated_at
//	    )
//	  ) AS metadata,
//	  pc.provider_name,
//	  pc.config AS provider_config,
//	  JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', json_extract(pc.metadata, '$.labels'), 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS pc_metadata,
//	  kask.legacy
//	FROM key_access_server_keys AS kask
//	INNER JOIN
//	    listed ON kask.key_access_server_id = listed.kas_id
//	LEFT JOIN
//	    provider_config as pc ON kask.provider_config_id = pc.id
//	WHERE
//	    ($1 IS NULL OR kask.key_algorithm = $1)
//	    AND ($2 IS NULL OR kask.legacy = $2)
//	ORDER BY kask.created_at DESC
//	LIMIT $4
//	OFFSET $3
func (q *Queries) ListKeys(ctx context.Context, arg ListKeysParams) ([]ListKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, listKeys,
		arg.KeyAlgorithm,
		arg.Legacy,
		arg.Offset,
		arg.Limit,
		arg.KasID,
		arg.KasName,
		arg.KasUri,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeysRow
	for rows.Next() {
		var i ListKeysRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.KeyID,
			&i.KeyStatus,
			&i.KeyMode,
			&i.KeyAlgorithm,
			&i.PrivateKeyCtx,
			&i.PublicKeyCtx,
			&i.ProviderConfigID,
			&i.KeyAccessServerID,
			&i.KasUri,
			&i.Metadata,
			&i.ProviderName,
			&i.ProviderConfig,
			&i.PcMetadata,
			&i.Legacy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setBaseKey = `-- name: SetBaseKey :execrows
INSERT INTO base_keys (id, key_access_server_key_id)
VALUES (gen_random_uuid(), $1)
`

// SetBaseKey
//
//	INSERT INTO base_keys (key_access_server_key_id)
//	VALUES ($1)
func (q *Queries) SetBaseKey(ctx context.Context, keyAccessServerKeyID sql.NullString) (int64, error) {
	result, err := q.db.ExecContext(ctx, setBaseKey, keyAccessServerKeyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateKey = `-- name: UpdateKey :execrows
UPDATE key_access_server_keys
SET
    key_status = COALESCE($2, key_status),
    metadata = COALESCE($3, metadata),
    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now', '+0.001 seconds')
WHERE id = $1
`

type UpdateKeyParams struct {
	ID        string         `json:"id"`
	KeyStatus sql.NullInt32  `json:"key_status"`
	Metadata  sql.NullString `json:"metadata"`
}

// UpdateKey
//
//	UPDATE key_access_server_keys
//	SET
//	    key_status = COALESCE($2, key_status),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) UpdateKey(ctx context.Context, arg UpdateKeyParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateKey, arg.ID, arg.KeyStatus, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateKeyAccessServer = `-- name: UpdateKeyAccessServer :execrows
UPDATE key_access_servers
SET
    uri = COALESCE($2, uri),
    public_key = COALESCE($3, public_key),
    name = COALESCE($4, name),
    metadata = COALESCE($5, metadata),
    source_type = COALESCE($6, source_type),
    updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now', '+0.001 seconds')
WHERE id = $1
`

type UpdateKeyAccessServerParams struct {
	ID         string         `json:"id"`
	Uri        sql.NullString `json:"uri"`
	PublicKey  sql.NullString `json:"public_key"`
	Name       sql.NullString `json:"name"`
	Metadata   sql.NullString `json:"metadata"`
	SourceType sql.NullString `json:"source_type"`
}

// UpdateKeyAccessServer
//
//	UPDATE key_access_servers
//	SET
//	    uri = COALESCE($2, uri),
//	    public_key = COALESCE($3, public_key),
//	    name = COALESCE($4, name),
//	    metadata = COALESCE($5, metadata),
//	    source_type = COALESCE($6, source_type)
//	WHERE id = $1
func (q *Queries) UpdateKeyAccessServer(ctx context.Context, arg UpdateKeyAccessServerParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateKeyAccessServer,
		arg.ID,
		arg.Uri,
		arg.PublicKey,
		arg.Name,
		arg.Metadata,
		arg.SourceType,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
